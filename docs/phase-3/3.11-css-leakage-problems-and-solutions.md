# 3.11 CSS Leakage: Problems and Solutions

## üéØ Overview

CSS leakage is one of the most common challenges in micro-frontend architecture. When styles from one MFE unintentionally affect another MFE or the host application, it breaks the fundamental principle of **isolation** that makes micro-frontends powerful.

## üö® The Problem: CSS Leakage

### What is CSS Leakage?

CSS leakage occurs when styles from one micro-frontend unintentionally affect:
- Other micro-frontends
- The host application
- Global page styles

This breaks the isolation boundary and can cause unpredictable visual bugs.

### üìä Common Leakage Scenarios

| Scenario | Problem | Impact |
|----------|---------|---------|
| **Global Selectors** | `body { font-family: Arial; }` | Affects entire page |
| **Common Class Names** | `.header`, `.button`, `.card` | Style conflicts between MFEs |
| **CSS Resets** | `* { margin: 0; padding: 0; }` | Overwrites all styles |
| **Third-party Libraries** | Bootstrap, Material-UI globals | Unexpected style inheritance |

## üîç Real-World Example

### The Problem in Action

**Host Application (`host/src/styles.css`):**
```css
.header {
  background-color: blue;
  color: white;
  padding: 1rem;
}

.button {
  background-color: green;
  border: none;
  padding: 0.5rem 1rem;
}
```

**Remote Application (`remote/src/styles.css`):**
```css
.header {
  background-color: red;  /* Conflicts with host! */
  font-size: 2rem;
}

.button {
  background-color: orange;  /* Overrides host button! */
  border-radius: 8px;
}
```

**Result:** Unpredictable styling where the last-loaded CSS wins, breaking both applications.

## üõ†Ô∏è Solution Strategies

### 1. **CSS Modules** (Recommended)

**How it works:** Generates unique class names automatically.

```css
/* styles.module.css */
.header {
  background-color: blue;
  color: white;
}

.button {
  background-color: green;
  padding: 0.5rem 1rem;
}
```

```typescript
// Component.tsx
import styles from './styles.module.css';

const Component = () => (
  <div className={styles.header}>
    <button className={styles.button}>Click me</button>
  </div>
);
```

**Generated Output:**
```html
<div class="header_a1b2c3">
  <button class="button_d4e5f6">Click me</button>
</div>
```

**Pros:**
- ‚úÖ Automatic scoping
- ‚úÖ No naming conflicts
- ‚úÖ TypeScript support
- ‚úÖ Works with existing CSS

**Cons:**
- ‚ö†Ô∏è Requires build configuration
- ‚ö†Ô∏è Different syntax from regular CSS

### 2. **BEM Methodology**

**How it works:** Structured naming convention to avoid conflicts.

```css
/* Host styles */
.host-header {
  background-color: blue;
}

.host-header__title {
  font-size: 1.5rem;
}

.host-header__button {
  background-color: green;
}

/* Remote styles */
.remote-dashboard {
  padding: 1rem;
}

.remote-dashboard__header {
  background-color: red;
}

.remote-dashboard__button {
  background-color: orange;
}
```

**Pros:**
- ‚úÖ No build configuration needed
- ‚úÖ Clear naming structure
- ‚úÖ Easy to understand

**Cons:**
- ‚ö†Ô∏è Manual discipline required
- ‚ö†Ô∏è Verbose class names
- ‚ö†Ô∏è No automatic enforcement

### 3. **Styled Components** (CSS-in-JS)

**How it works:** Styles are scoped to components automatically.

```typescript
import styled from 'styled-components';

const Header = styled.div`
  background-color: blue;
  color: white;
  padding: 1rem;
`;

const Button = styled.button`
  background-color: green;
  border: none;
  padding: 0.5rem 1rem;
`;

const Component = () => (
  <Header>
    <Button>Click me</Button>
  </Header>
);
```

**Generated Output:**
```html
<div class="sc-bczRLJ gQDOBc">
  <button class="sc-gsnTZi hKLGxY">Click me</button>
</div>
```

**Pros:**
- ‚úÖ Automatic scoping
- ‚úÖ Dynamic styling
- ‚úÖ TypeScript support
- ‚úÖ No CSS files needed

**Cons:**
- ‚ö†Ô∏è Runtime overhead
- ‚ö†Ô∏è Larger bundle size
- ‚ö†Ô∏è Different development paradigm

### 4. **Shadow DOM** (Advanced)

**How it works:** Creates isolated DOM subtrees with encapsulated styles.

```typescript
class IsolatedComponent extends HTMLElement {
  constructor() {
    super();
    const shadow = this.attachShadow({ mode: 'closed' });
    
    shadow.innerHTML = `
      <style>
        .header {
          background-color: blue;
          color: white;
        }
      </style>
      <div class="header">
        <slot></slot>
      </div>
    `;
  }
}

customElements.define('isolated-component', IsolatedComponent);
```

**Pros:**
- ‚úÖ Complete style isolation
- ‚úÖ Native browser support
- ‚úÖ No build tools needed

**Cons:**
- ‚ö†Ô∏è Limited browser support (older versions)
- ‚ö†Ô∏è Complex integration with React
- ‚ö†Ô∏è Debugging challenges

## üîß Implementation Guide

### Webpack Configuration for CSS Modules

```javascript
// webpack.config.js
module.exports = {
  module: {
    rules: [
      {
        test: /\.module\.css$/,
        use: [
          'style-loader',
          {
            loader: 'css-loader',
            options: {
              modules: {
                localIdentName: '[name]__[local]__[hash:base64:5]'
              }
            }
          }
        ]
      },
      {
        test: /\.css$/,
        exclude: /\.module\.css$/,
        use: ['style-loader', 'css-loader']
      }
    ]
  }
};
```

### TypeScript Declaration for CSS Modules

```typescript
// types/css-modules.d.ts
declare module '*.module.css' {
  const classes: { [key: string]: string };
  export default classes;
}
```

## üéØ Best Practices

### Do's ‚úÖ

1. **Use CSS Modules** for automatic scoping
2. **Prefix global styles** with your MFE name
3. **Avoid global CSS resets** in individual MFEs
4. **Use PostCSS** for vendor prefixing
5. **Test cross-MFE styling** in integration environment

### Don'ts ‚ùå

1. **Don't use generic class names** like `.header`, `.button`
2. **Don't import global stylesheets** in MFEs
3. **Don't rely on CSS specificity** to override styles
4. **Don't use `!important`** as a quick fix
5. **Don't forget to test** in the host environment

## üß™ Practical Demo

### Try the Working Example

```bash
# Run the styling isolation demo
cd webpack-mfe/styling-isolation-demo
yarn start
```

This demo shows:
- CSS leakage problems in action
- Multiple solution approaches
- Before/after comparisons

## üéØ Summary

CSS leakage is a critical challenge in micro-frontends that requires:

- **Understanding the problem** - Why styles leak between MFEs
- **Choosing the right solution** - CSS Modules, BEM, or CSS-in-JS
- **Proper implementation** - Build configuration and best practices
- **Testing and validation** - Ensuring isolation works in practice

## üîÑ Next Steps

- **[3.12 CSS Modules Implementation](./3.12-css-modules-implementation.md)** - Detailed CSS Modules setup
- **[3.13 Shared Design Systems](./3.13-shared-design-systems.md)** - Consistent styling across MFEs
- **[Styling Isolation Demo](../../webpack-mfe/styling-isolation-demo/)** - Hands-on implementation
