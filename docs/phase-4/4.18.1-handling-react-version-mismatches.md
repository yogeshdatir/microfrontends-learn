# Handling React Version Mismatches in Micro-Frontends

## Overview

One of the most challenging aspects of micro-frontend architecture is managing dependency version conflicts, particularly with React. Different teams may need to use different React versions due to migration timelines, feature requirements, or legacy constraints.

This guide explores various strategies to handle React version mismatches across micro-frontends.

---

## The Challenge

When different micro-frontends use different React versions, several issues can arise:

- **Runtime Conflicts**: Multiple React versions trying to share the same DOM
- **Context Mixing**: React contexts from different versions don't work together
- **Hook Incompatibility**: Different hook implementations across versions
- **Bundle Duplication**: Multiple React versions increase bundle size
- **Type Conflicts**: TypeScript definitions may clash
- **State Management**: Shared state libraries may not work across versions

---

## Strategy 1: Complete React Isolation üîí

**Best for**: Maximum stability and compatibility across any React version combination

### How It Works

Each micro-frontend bundles its own React version completely independently. The host manages DOM containers, and remotes expose mount/unmount lifecycle methods.

### Implementation

**Vite Configuration - Host**:
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig({
  plugins: [
    react(),
    federation({
      name: 'host',
      remotes: {
        remote: 'http://localhost:3001/assets/remoteEntry.js',
      },
      shared: {} // Complete isolation - no shared dependencies
    })
  ],
  server: {
    port: 3000
  },
  build: {
    target: 'esnext'
  }
})
```

**Vite Configuration - Remote**:
```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import federation from '@originjs/vite-plugin-federation'

export default defineConfig({
  plugins: [
    react(),
    federation({
      name: 'remote',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/RemoteWrapper',
      },
      shared: {} // Complete isolation
    })
  ],
  server: {
    port: 3001
  },
  build: {
    target: 'esnext'
  }
})
```

**Remote Wrapper** (React 19 example):
```typescript
import { createRoot } from 'react-dom/client'
import type { Root } from 'react-dom/client'
import App from './App'

let root: Root | null = null

export default {
  mount: (element: HTMLElement) => {
    if (!root) {
      root = createRoot(element)
    }
    root.render(<App />)
  },

  unmount: () => {
    if (root) {
      root.unmount()
      root = null
    }
  }
}
```

**Host Integration**:
```typescript
import { useEffect, useRef } from 'react'

function HostApp() {
  const remoteRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const loadRemoteApp = async () => {
      try {
        const remoteModule = await import('remote/App')
        if (remoteRef.current && remoteModule.default) {
          remoteModule.default.mount(remoteRef.current)
        }
      } catch (error) {
        console.error('Failed to load remote app:', error)
      }
    }

    loadRemoteApp()

    return () => {
      if (remoteRef.current) {
        import('remote/App').then(remoteModule => {
          if (remoteModule.default) {
            remoteModule.default.unmount()
          }
        })
      }
    }
  }, [])

  return (
    <div>
      <h1>Host App (React 17)</h1>
      <div ref={remoteRef} />
    </div>
  )
}
```

**TypeScript Declarations**:
```typescript
declare module 'remote/App' {
  const App: {
    mount: (element: HTMLElement) => void
    unmount: () => void
  }
  export default App
}
```

### Pros
- ‚úÖ Works with any React version combination (17 ‚Üî 18, 17 ‚Üî 19, 18 ‚Üî 19)
- ‚úÖ No runtime conflicts or context mixing
- ‚úÖ Complete independence for each micro-frontend
- ‚úÖ Teams can upgrade React independently
- ‚úÖ Predictable behavior and maximum stability

### Cons
- ‚ùå Larger bundle size (each app includes full React)
- ‚ùå Cannot share React context between apps
- ‚ùå More memory usage (separate virtual DOM trees)
- ‚ùå Manual lifecycle management required

### When to Use
- Different teams on different React upgrade schedules
- Legacy apps that cannot be upgraded easily
- Maximum stability is critical
- Bundle size is not a primary concern

---

## Strategy 2: React Bridge Pattern üåâ

**Best for**: Component-level integration with simpler API

### How It Works

Uses `@module-federation/bridge-react` to create a compatibility layer between React versions. The bridge handles version differences automatically.

### Implementation

**Install Bridge**:
```bash
yarn add @module-federation/bridge-react
```

**Remote Setup**:
```typescript
import { createBridgeComponent } from '@module-federation/bridge-react'
import App from './App'

export default createBridgeComponent({
  rootComponent: App
})
```

**Host Setup**:
```typescript
import { loadRemote } from '@module-federation/bridge-react'

function HostApp() {
  const RemoteApp = loadRemote('remote/App')

  return (
    <div>
      <h1>Host App</h1>
      <RemoteApp someProp="value" />
    </div>
  )
}
```

### Pros
- ‚úÖ Simpler API than manual mount/unmount
- ‚úÖ Component-level integration feels natural
- ‚úÖ Props can be passed like normal components
- ‚úÖ Handles lifecycle automatically

### Cons
- ‚ùå Additional dependency required
- ‚ùå Limited version combinations supported
- ‚ùå Less control over integration details
- ‚ùå Still bundles separate React versions

### When to Use
- Need simpler integration API
- Working with officially supported version combinations
- Component-level integration preferred over app-level

---

## Strategy 3: Shared React with Singletons ‚ö°

**Best for**: When all micro-frontends can standardize on the same React version

### How It Works

Module Federation's `shared` configuration forces a single React instance across all micro-frontends.

### Implementation

**Vite Configuration**:
```typescript
federation({
  name: 'host',
  remotes: {
    remote: 'http://localhost:3001/assets/remoteEntry.js'
  },
  shared: {
    react: {
      singleton: true,
      requiredVersion: '^18.0.0'
    },
    'react-dom': {
      singleton: true,
      requiredVersion: '^18.0.0'
    }
  }
})
```

**Webpack Configuration**:
```javascript
new ModuleFederationPlugin({
  name: 'host',
  remotes: {
    remote: 'remote@http://localhost:3001/remoteEntry.js'
  },
  shared: {
    react: { singleton: true, requiredVersion: '^18.0.0' },
    'react-dom': { singleton: true, requiredVersion: '^18.0.0' }
  }
})
```

### Pros
- ‚úÖ Smallest bundle size
- ‚úÖ Shared React context works across apps
- ‚úÖ Single virtual DOM
- ‚úÖ Better performance
- ‚úÖ Hooks and state management work seamlessly

### Cons
- ‚ùå All apps must use compatible versions
- ‚ùå Forces version alignment across teams
- ‚ùå Potential runtime errors if versions mismatch
- ‚ùå Limits independent deployment flexibility

### When to Use
- All teams can coordinate on React version
- Bundle size optimization is critical
- Need shared context/state across apps
- Migration can happen in coordinated fashion

---

## Strategy 4: Web Components Wrapper üéÅ

**Best for**: Framework-agnostic isolation

### How It Works

Wrap React micro-frontends as custom elements (Web Components), providing true framework isolation.

### Implementation

**Remote as Web Component**:
```typescript
import { createRoot } from 'react-dom/client'
import App from './App'

class RemoteApp extends HTMLElement {
  private root: any

  connectedCallback() {
    this.root = createRoot(this)
    this.root.render(<App />)
  }

  disconnectedCallback() {
    this.root?.unmount()
  }

  attributeChangedCallback(name: string, oldValue: string, newValue: string) {
    // Handle prop changes
    this.root?.render(<App {...this.getProps()} />)
  }

  private getProps() {
    return {
      // Parse attributes to props
    }
  }
}

customElements.define('remote-app', RemoteApp)
```

**Host Usage**:
```typescript
function HostApp() {
  return (
    <div>
      <h1>Host App</h1>
      <remote-app data-prop="value"></remote-app>
    </div>
  )
}
```

### Pros
- ‚úÖ True framework isolation
- ‚úÖ Works with any framework combination
- ‚úÖ Standards-based approach
- ‚úÖ Shadow DOM support for style isolation

### Cons
- ‚ùå Props passing is more complex
- ‚ùå Custom event handling required
- ‚ùå TypeScript support is limited
- ‚ùå Debugging can be harder

### When to Use
- Mixing multiple frameworks (React + Vue + Angular)
- Need maximum isolation
- Long-term framework agnostic architecture
- Style isolation is critical (Shadow DOM)

---

## Strategy 5: IFrame Isolation üì¶

**Best for**: Legacy apps or maximum security isolation

### How It Works

Load micro-frontends in iframes with `postMessage` for communication.

### Implementation

**Host**:
```typescript
function HostApp() {
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.origin !== 'http://localhost:3001') return
      console.log('Message from remote:', event.data)
    }

    window.addEventListener('message', handleMessage)
    return () => window.removeEventListener('message', handleMessage)
  }, [])

  return (
    <div>
      <h1>Host App</h1>
      <iframe
        src="http://localhost:3001"
        style={{ width: '100%', height: '500px', border: 'none' }}
      />
    </div>
  )
}
```

**Remote Communication**:
```typescript
// In remote app
window.parent.postMessage({ type: 'NAVIGATION', path: '/about' }, '*')
```

### Pros
- ‚úÖ Complete isolation (security, styles, scripts)
- ‚úÖ Works with any framework/version
- ‚úÖ Legacy app integration is straightforward
- ‚úÖ No build configuration needed

### Cons
- ‚ùå Styling/layout challenges
- ‚ùå Performance overhead
- ‚ùå Complex communication patterns
- ‚ùå SEO and accessibility issues
- ‚ùå User experience limitations

### When to Use
- Integrating third-party or legacy apps
- Maximum security isolation required
- Cannot modify remote app code
- Quick prototyping or temporary solutions

---

## Strategy 6: Layer-based Architecture (Route Isolation) üó∫Ô∏è

**Best for**: Simplifying version management through routing

### How It Works

Different React versions live on different routes - no mixing on the same page.

### Implementation

**App Router**:
```typescript
import { BrowserRouter, Routes, Route } from 'react-router-dom'

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/app1/*" element={<App1 />} /> {/* React 17 */}
        <Route path="/app2/*" element={<App2 />} /> {/* React 18 */}
        <Route path="/app3/*" element={<App3 />} /> {/* React 19 */}
      </Routes>
    </BrowserRouter>
  )
}
```

### Pros
- ‚úÖ Simplest approach
- ‚úÖ No version conflicts possible
- ‚úÖ Clear ownership boundaries
- ‚úÖ Easy to reason about

### Cons
- ‚ùå Cannot compose components from different versions on same page
- ‚ùå Less flexible UI composition
- ‚ùå Full page reloads between apps

### When to Use
- Different apps serve different purposes
- No need for tight integration
- Simplified architecture preferred
- Clear team/domain boundaries

---

## Comparison Matrix

| Strategy | Bundle Size | Complexity | Flexibility | Stability | Use Cases |
|----------|-------------|------------|-------------|-----------|-----------|
| **Complete Isolation** | ‚ùå Large | ‚ö†Ô∏è Medium | ‚úÖ High | ‚úÖ Excellent | Different versions needed |
| **React Bridge** | ‚ùå Large | ‚úÖ Low | ‚ö†Ô∏è Medium | ‚úÖ Good | Simpler integration |
| **Shared Singleton** | ‚úÖ Small | ‚úÖ Low | ‚ùå Low | ‚ö†Ô∏è Medium | Same version possible |
| **Web Components** | ‚ùå Large | ‚ùå High | ‚úÖ High | ‚úÖ Good | Framework agnostic |
| **IFrame** | ‚ö†Ô∏è Medium | ‚ö†Ô∏è Medium | ‚ùå Low | ‚úÖ Excellent | Legacy/third-party |
| **Route Isolation** | ‚ö†Ô∏è Medium | ‚úÖ Low | ‚ùå Low | ‚úÖ Excellent | Simple boundaries |

---

## Decision Tree

```
Do all teams use the same React version?
‚îú‚îÄ YES ‚Üí Use Shared Singleton (Strategy 3)
‚îî‚îÄ NO ‚Üí Continue
    ‚îÇ
    Can you coordinate version upgrades?
    ‚îú‚îÄ YES ‚Üí Use Shared Singleton (Strategy 3)
    ‚îî‚îÄ NO ‚Üí Continue
        ‚îÇ
        Need component composition on same page?
        ‚îú‚îÄ NO ‚Üí Use Route Isolation (Strategy 6)
        ‚îî‚îÄ YES ‚Üí Continue
            ‚îÇ
            Want simplest integration API?
            ‚îú‚îÄ YES ‚Üí Use React Bridge (Strategy 2)
            ‚îî‚îÄ NO ‚Üí Continue
                ‚îÇ
                Mixing frameworks (not just React)?
                ‚îú‚îÄ YES ‚Üí Use Web Components (Strategy 4)
                ‚îî‚îÄ NO ‚Üí Use Complete Isolation (Strategy 1)
```

---

## Best Practices

### General Guidelines

1. **Start Simple**: Use shared singleton if possible, only add isolation when needed
2. **Document Versions**: Maintain a registry of which micro-frontend uses which React version
3. **Monitor Bundle Size**: Track the impact of multiple React versions
4. **Test Thoroughly**: Test all version combinations in integration
5. **Plan Upgrades**: Create a roadmap for converging on a single version eventually

### Development Workflow

1. **Build Remote First**: When using Vite, build remotes before running host
2. **Version Lock**: Use exact versions in package.json to prevent surprises
3. **Type Safety**: Maintain TypeScript declarations for all remote modules
4. **Error Boundaries**: Wrap remote components in error boundaries
5. **Fallback UI**: Always provide fallback for failed remote loads

### Performance Optimization

1. **Lazy Load**: Only load remotes when needed
2. **Preload**: Preload critical remotes during idle time
3. **Cache**: Configure proper caching headers for remote entry files
4. **Monitor**: Track bundle sizes and runtime performance
5. **CDN**: Serve static assets from CDN to improve load times

---

## Real-World Example: Migration Strategy

### Scenario
Large application with 5 micro-frontends, need to migrate from React 17 to React 19.

### Approach

**Phase 1**: Use Complete Isolation
- Allow teams to upgrade independently
- Host stays on React 17
- Remotes upgrade one by one to React 19

**Phase 2**: Gradual Convergence
- Once 80% of apps are on React 19, upgrade host
- Use React Bridge for remaining React 17 apps

**Phase 3**: Consolidation
- Upgrade last apps to React 19
- Switch to Shared Singleton configuration
- Enjoy smaller bundle sizes

**Timeline**: 6-12 months for full migration

---

## References

- [Module Federation Documentation](https://module-federation.io/)
- [React 19 Migration Guide](https://react.dev/blog/2024/04/25/react-19)
- [Vite Plugin Federation](https://github.com/originjs/vite-plugin-federation)
- [@module-federation/bridge-react](https://www.npmjs.com/package/@module-federation/bridge-react)
- [Web Components with React](https://react.dev/reference/react-dom/components#custom-html-elements)

---

## Summary

Handling React version mismatches in micro-frontends requires careful consideration of trade-offs:

- **Complete Isolation**: Best for maximum flexibility and stability
- **React Bridge**: Best for simpler API with version isolation
- **Shared Singleton**: Best for coordinated teams on same version
- **Web Components**: Best for framework-agnostic architecture
- **IFrame**: Best for legacy integration
- **Route Isolation**: Best for simple, clear boundaries

Choose the strategy that best fits your team structure, migration timeline, and technical requirements. Remember that you can also mix strategies - using isolation for some remotes and shared dependencies for others.
