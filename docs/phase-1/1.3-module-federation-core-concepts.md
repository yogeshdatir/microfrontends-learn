# 1.3 Module Federation: Core Concepts

## ðŸŽ¯ Overview

Module Federation is a JavaScript architecture pattern that allows multiple independent applications to share code and dependencies at runtime. It's the technical foundation that makes modern micro-frontend architecture possible.

## ðŸ—ï¸ Core Architecture

### What is Module Federation?

Module Federation enables:
- **Runtime code sharing** between separate applications
- **Dynamic imports** of remote modules
- **Shared dependency management** to avoid duplication
- **Independent deployment** of federated applications

### Key Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Module Federation System                 â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚    Host     â”‚  imports  â”‚   Remote    â”‚             â”‚
â”‚  â”‚ Application â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ Application â”‚             â”‚
â”‚  â”‚             â”‚           â”‚             â”‚             â”‚
â”‚  â”‚ â€¢ Container â”‚           â”‚ â€¢ Container â”‚             â”‚
â”‚  â”‚ â€¢ Remotes   â”‚           â”‚ â€¢ Exposes   â”‚             â”‚
â”‚  â”‚ â€¢ Shared    â”‚           â”‚ â€¢ Shared    â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            Shared Dependencies              â”‚   â”‚
â”‚  â”‚  â€¢ React, ReactDOM, Lodash, etc.           â”‚   â”‚
â”‚  â”‚  â€¢ Version negotiation                     â”‚   â”‚
â”‚  â”‚  â€¢ Singleton enforcement                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ðŸ”‘ Fundamental Concepts

### 1. **Container**

The container is the entry point for a federated application.

| Aspect | Description |
|--------|-------------|
| **Purpose** | Bootstraps the federated application |
| **Location** | Usually named `remoteEntry.js` |
| **Contains** | Module metadata, exposed modules, shared dependencies |
| **Loading** | Loaded dynamically by consuming applications |

### 2. **Host Application**

The application that consumes remote modules.

```javascript
// Host webpack configuration
new ModuleFederationPlugin({
  name: 'host',
  remotes: {
    'remote-app': 'remoteApp@http://localhost:3001/remoteEntry.js'
  },
  shared: {
    react: { singleton: true },
    'react-dom': { singleton: true }
  }
})
```

### 3. **Remote Application**

The application that exposes modules for consumption.

```javascript
// Remote webpack configuration
new ModuleFederationPlugin({
  name: 'remoteApp',
  filename: 'remoteEntry.js',
  exposes: {
    './App': './src/App',
    './Button': './src/components/Button'
  },
  shared: {
    react: { singleton: true },
    'react-dom': { singleton: true }
  }
})
```

### 4. **Shared Dependencies**

Dependencies that are shared between applications to avoid duplication.

| Configuration | Purpose | Example |
|---------------|---------|---------|
| **singleton** | Ensure only one instance | `react: { singleton: true }` |
| **eager** | Load immediately | `lodash: { eager: true }` |
| **requiredVersion** | Specify version constraints | `react: { requiredVersion: '^18.0.0' }` |

## ðŸš€ Module Federation Workflow

### Runtime Loading Process

```
1. Host Application Starts
   â†“
2. Host Loads Remote Container
   â†“
3. Version Negotiation (Shared Dependencies)
   â†“
4. Dynamic Import of Remote Module
   â†“
5. Module Execution in Host Context
   â†“
6. Component Renders in Host DOM
```

### Development Workflow

```
1. Define Federation Configuration
   â†“
2. Configure Webpack Module Federation Plugin
   â†“
3. Set Up Shared Dependencies
   â†“
4. Expose Modules (Remote)
   â†“
5. Consume Modules (Host)
   â†“
6. Handle Loading States and Errors
```

## ðŸ”§ Configuration Deep Dive

### Host Configuration Options

| Option | Purpose | Example |
|--------|---------|---------|
| **name** | Application identifier | `name: 'host'` |
| **remotes** | Remote applications to consume | `remotes: { 'app': 'app@url/remoteEntry.js' }` |
| **shared** | Dependencies to share | `shared: { react: { singleton: true } }` |
| **exposes** | Modules to expose (if bidirectional) | `exposes: { './utils': './src/utils' }` |

### Remote Configuration Options

| Option | Purpose | Example |
|--------|---------|---------|
| **name** | Application identifier | `name: 'remoteApp'` |
| **filename** | Container filename | `filename: 'remoteEntry.js'` |
| **exposes** | Modules to expose | `exposes: { './App': './src/App' }` |
| **shared** | Dependencies to share | `shared: { react: { singleton: true } }` |

### Shared Dependency Strategies

```javascript
// Basic sharing
shared: {
  react: { singleton: true },
  'react-dom': { singleton: true }
}

// Advanced sharing with version control
shared: {
  react: {
    singleton: true,
    requiredVersion: '^18.0.0',
    eager: false
  },
  lodash: {
    singleton: false,
    eager: true,
    requiredVersion: '^4.17.0'
  }
}
```

## ðŸŽ¯ Loading Patterns

### 1. **Static Loading**

```javascript
// Direct import (known at build time)
import RemoteApp from 'remote-app/App';

const App = () => {
  return (
    <div>
      <RemoteApp />
    </div>
  );
};
```

### 2. **Dynamic Loading**

```javascript
// Dynamic import with React.lazy
const RemoteApp = React.lazy(() => import('remote-app/App'));

const App = () => {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <RemoteApp />
      </Suspense>
    </div>
  );
};
```

### 3. **Runtime Loading**

```javascript
// Programmatic loading
const loadRemoteModule = async () => {
  try {
    const module = await import('remote-app/App');
    return module.default;
  } catch (error) {
    console.error('Failed to load remote module:', error);
    return null;
  }
};
```

## ðŸ”„ Dependency Resolution

### Version Negotiation Process

```
1. Host and Remote declare shared dependencies
   â†“
2. Module Federation compares versions
   â†“
3. Highest compatible version wins
   â†“
4. Single instance shared across applications
   â†“
5. Fallback to bundled version if incompatible
```

### Singleton Enforcement

| Scenario | Behavior |
|----------|----------|
| **Compatible versions** | Share highest version |
| **Incompatible versions** | Use host version, warn about remote |
| **Missing dependency** | Load from remote bundle |
| **Eager loading** | Load immediately at startup |

## âš¡ Performance Considerations

### Loading Strategies

| Strategy | Pros | Cons | Use Case |
|----------|------|------|----------|
| **Eager Loading** | Fast runtime access | Larger initial bundle | Critical dependencies |
| **Lazy Loading** | Smaller initial bundle | Runtime loading delay | Optional features |
| **Preloading** | Balance of both | Complex setup | Predictable user flows |

### Bundle Optimization

```javascript
// Optimize shared dependencies
shared: {
  react: {
    singleton: true,
    eager: true,  // Load immediately
    requiredVersion: '^18.0.0'
  },
  'react-dom': {
    singleton: true,
    eager: true
  },
  lodash: {
    singleton: false,  // Allow multiple versions
    eager: false       // Load on demand
  }
}
```

## ðŸš¨ Error Handling

### Common Error Scenarios

| Error Type | Cause | Solution |
|------------|-------|----------|
| **Module Not Found** | Remote not available | Fallback component |
| **Version Mismatch** | Incompatible dependencies | Version alignment |
| **Network Failure** | Remote server down | Graceful degradation |
| **Loading Timeout** | Slow network | Loading states |

### Error Handling Patterns

```javascript
// Error boundary for remote modules
class RemoteErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Remote module error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <div>Failed to load remote module</div>;
    }
    return this.props.children;
  }
}
```

## ðŸŽ¯ Best Practices

### Configuration Best Practices

1. **Use semantic versioning** for shared dependencies
2. **Enable singleton** for framework libraries (React, Vue)
3. **Implement error boundaries** for remote modules
4. **Use TypeScript** for better type safety
5. **Monitor bundle sizes** and loading performance

### Development Best Practices

1. **Start remote applications first** during development
2. **Use consistent naming conventions** for exposed modules
3. **Document exposed APIs** for consuming teams
4. **Implement health checks** for remote endpoints
5. **Use environment-specific** remote URLs

## ðŸ”„ Development vs Production

### Development Setup

```javascript
// Development - localhost URLs
remotes: {
  'remote-app': 'remoteApp@http://localhost:3001/remoteEntry.js'
}
```

### Production Setup

```javascript
// Production - CDN or production URLs
remotes: {
  'remote-app': 'remoteApp@https://cdn.example.com/remoteEntry.js'
}
```

## ðŸŽ¯ Summary

Module Federation enables runtime code sharing through:

- **Dynamic module loading** at runtime
- **Shared dependency management** with version negotiation
- **Independent deployment** of federated applications
- **Flexible loading patterns** (static, dynamic, runtime)

## ðŸ”„ Next Steps

Now that you understand Module Federation fundamentals:

- **[1.4 Host vs Remote Communication](./1.4-host-vs-remote-communication.md)** - Learn communication patterns
- **[1.5 Basic Host and Remote Setup](./1.5-basic-host-remote-setup.md)** - See practical implementation
- **[../../webpack-mfe/docs/mfe/](../../webpack-mfe/docs/mfe/)** - Detailed Webpack configuration guides

## ðŸ“š Further Reading

- **[Webpack Module Federation Documentation](https://webpack.js.org/concepts/module-federation/)**
- **[Module Federation Examples](https://github.com/module-federation/module-federation-examples)**
- **[Advanced Module Federation Patterns](../../webpack-mfe/docs/mfe/webpack-module-federation-setup.md)** 