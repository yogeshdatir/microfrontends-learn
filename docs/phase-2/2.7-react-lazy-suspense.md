# 2.7 React.lazy + Suspense with Remote Modules

> **What you'll learn**: Production-ready loading patterns, bulletproof error handling, and performance optimization for remote components
> üìä **Difficulty**: Intermediate | üõ†Ô∏è **Prerequisites**: 2.6 Basic Module Federation setup

## üéØ Quick Start: Beyond Basic Loading

### The Problem with Basic Lazy Loading
```tsx
// ‚ùå Basic approach - works but limited
const RemoteApp = lazy(() => import('remote/App'));

const App = () => (
  <Suspense fallback={<div>Loading...</div>}>
    <RemoteApp />
  </Suspense>
);
```

**Issues:**
- No error handling if remote fails
- Generic loading state
- No retry mechanism
- Poor user experience on slow networks

### ‚úÖ Production-Ready Pattern
```tsx
// ‚úÖ Enhanced approach - Copy this template
import React, { Suspense, lazy, useState, useEffect } from 'react';

const RemoteApp = lazy(() =>
  import('remote/App').catch(() => ({
    default: () => <div>Failed to load remote component</div>
  }))
);

const LoadingSpinner = () => (
  <div className="loading-container">
    <div className="spinner" />
    <p>Loading remote component...</p>
  </div>
);

const App = () => (
  <Suspense fallback={<LoadingSpinner />}>
    <RemoteApp />
  </Suspense>
);
```

‚úÖ **Test It Works**:
```bash
# 1. Start both host and remote (from 2.6 setup)
# 2. Visit http://localhost:3000
# 3. Open Network tab - should see graceful loading
# 4. Simulate network failure: throttle to "Offline" in DevTools
# 5. Refresh - should see fallback message instead of crash
```

---

## üîÑ Advanced Loading Patterns

### 1. Retry Mechanism with Exponential Backoff

```tsx
// utils/remoteLoader.ts
export const createRemoteLoader = (
  importFn: () => Promise<any>,
  maxRetries = 3,
  baseDelay = 1000
) => {
  let retryCount = 0;

  const loadWithRetry = async (): Promise<any> => {
    try {
      return await importFn();
    } catch (error) {
      if (retryCount < maxRetries) {
        retryCount++;
        const delay = baseDelay * Math.pow(2, retryCount - 1);

        console.warn(`Remote load failed, retrying in ${delay}ms... (${retryCount}/${maxRetries})`);

        await new Promise(resolve => setTimeout(resolve, delay));
        return loadWithRetry();
      }

      throw new Error(`Failed to load remote after ${maxRetries} attempts: ${error.message}`);
    }
  };

  return loadWithRetry;
};

// Usage
const RemoteApp = lazy(createRemoteLoader(() => import('remote/App')));
```

### 2. Conditional Loading with Feature Flags

```tsx
// hooks/useRemoteComponent.ts
import { lazy, useMemo } from 'react';

interface UseRemoteComponentOptions {
  enabled?: boolean;
  fallback?: React.ComponentType;
}

export const useRemoteComponent = (
  importFn: () => Promise<any>,
  options: UseRemoteComponentOptions = {}
) => {
  const { enabled = true, fallback } = options;

  const Component = useMemo(() => {
    if (!enabled) {
      return fallback || (() => null);
    }

    return lazy(() =>
      importFn().catch(() => ({
        default: fallback || (() => <div>Component unavailable</div>)
      }))
    );
  }, [enabled, importFn, fallback]);

  return Component;
};

// Usage
const App = () => {
  const RemoteApp = useRemoteComponent(
    () => import('remote/App'),
    {
      enabled: process.env.NODE_ENV === 'production',
      fallback: () => <div>Feature not available in development</div>
    }
  );

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <RemoteApp />
    </Suspense>
  );
};
```

### 3. Preloading Strategy

```tsx
// utils/preloader.ts
const remoteModuleCache = new Map<string, Promise<any>>();

export const preloadRemoteModule = (moduleName: string, importFn: () => Promise<any>) => {
  if (!remoteModuleCache.has(moduleName)) {
    remoteModuleCache.set(moduleName, importFn());
  }
  return remoteModuleCache.get(moduleName)!;
};

export const createPreloadedLazy = (moduleName: string, importFn: () => Promise<any>) => {
  return lazy(() => preloadRemoteModule(moduleName, importFn));
};

// Usage - Preload on route change or user interaction
const preloadComponents = () => {
  preloadRemoteModule('remoteApp', () => import('remote/App'));
  preloadRemoteModule('remoteButton', () => import('remote/Button'));
};

// Preload on hover
<button
  onMouseEnter={preloadComponents}
  onClick={navigateToRemotePage}
>
  Go to Remote Page
</button>
```

---

## üõ°Ô∏è Advanced Error Handling

### 1. Smart Error Boundary with Retry

```tsx
// components/RemoteErrorBoundary.tsx
import React, { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: any) => void;
}

interface State {
  hasError: boolean;
  error?: Error;
  retryCount: number;
}

export class RemoteErrorBoundary extends Component<Props, State> {
  private maxRetries = 3;

  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, retryCount: 0 };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error, retryCount: 0 };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Remote component error:', error, errorInfo);
    this.props.onError?.(error, errorInfo);

    // Report to monitoring service
    this.reportError(error, errorInfo);
  }

  reportError = (error: Error, errorInfo: any) => {
    // Integration with error monitoring services
    if (typeof window !== 'undefined' && window.dataLayer) {
      window.dataLayer.push({
        event: 'remote_component_error',
        error_message: error.message,
        component_stack: errorInfo.componentStack
      });
    }
  };

  handleRetry = () => {
    if (this.state.retryCount < this.maxRetries) {
      this.setState(prevState => ({
        hasError: false,
        error: undefined,
        retryCount: prevState.retryCount + 1
      }));
    }
  };

  render() {
    if (this.state.hasError) {
      const canRetry = this.state.retryCount < this.maxRetries;

      return this.props.fallback || (
        <div className="error-boundary">
          <h3>üö´ Remote Component Failed</h3>
          <p>Error: {this.state.error?.message}</p>
          <p>Attempt: {this.state.retryCount + 1}/{this.maxRetries + 1}</p>
          {canRetry && (
            <button onClick={this.handleRetry} className="retry-button">
              üîÑ Retry Loading
            </button>
          )}
          {!canRetry && (
            <p>Component is temporarily unavailable. Please refresh the page.</p>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 2. Network-Aware Loading

```tsx
// hooks/useNetworkStatus.ts
import { useState, useEffect } from 'react';

export const useNetworkStatus = () => {
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  );
  const [connectionType, setConnectionType] = useState<string>('unknown');

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // Network Information API (experimental)
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      setConnectionType(connection.effectiveType || 'unknown');

      const handleConnectionChange = () => {
        setConnectionType(connection.effectiveType || 'unknown');
      };

      connection.addEventListener('change', handleConnectionChange);

      return () => {
        connection.removeEventListener('change', handleConnectionChange);
        window.removeEventListener('online', handleOnline);
        window.removeEventListener('offline', handleOffline);
      };
    }

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return { isOnline, connectionType };
};

// Network-aware component loading
const NetworkAwareRemoteLoader = ({ children }: { children: ReactNode }) => {
  const { isOnline, connectionType } = useNetworkStatus();

  if (!isOnline) {
    return (
      <div className="offline-message">
        <p>üåê You're offline. Remote components are not available.</p>
      </div>
    );
  }

  if (connectionType === 'slow-2g') {
    return (
      <div className="slow-connection-warning">
        <p>‚ö†Ô∏è Slow connection detected. Remote components may take longer to load.</p>
        {children}
      </div>
    );
  }

  return <>{children}</>;
};
```

---

## üìä Performance Optimization

### 1. Intelligent Loading States

```tsx
// components/SmartSuspense.tsx
import React, { Suspense, useState, useEffect } from 'react';

interface SmartSuspenseProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
  minLoadingTime?: number; // Prevent flash of loading state
  timeout?: number; // Show timeout message
}

export const SmartSuspense: React.FC<SmartSuspenseProps> = ({
  children,
  fallback,
  minLoadingTime = 200,
  timeout = 10000
}) => {
  const [showFallback, setShowFallback] = useState(false);
  const [showTimeout, setShowTimeout] = useState(false);

  useEffect(() => {
    const minTimer = setTimeout(() => setShowFallback(true), minLoadingTime);
    const timeoutTimer = setTimeout(() => setShowTimeout(true), timeout);

    return () => {
      clearTimeout(minTimer);
      clearTimeout(timeoutTimer);
    };
  }, [minLoadingTime, timeout]);

  const loadingFallback = showTimeout ? (
    <div className="timeout-message">
      <p>‚è±Ô∏è This is taking longer than expected...</p>
      <button onClick={() => window.location.reload()}>
        Refresh Page
      </button>
    </div>
  ) : showFallback ? (
    fallback || <div>Loading...</div>
  ) : null;

  return (
    <Suspense fallback={loadingFallback}>
      {children}
    </Suspense>
  );
};
```

### 2. Bundle Size Monitoring

```tsx
// utils/bundleMonitor.ts
interface LoadMetrics {
  componentName: string;
  loadTime: number;
  bundleSize?: number;
  cacheHit: boolean;
}

class BundleMonitor {
  private metrics: LoadMetrics[] = [];

  trackComponentLoad = async (
    componentName: string,
    importFn: () => Promise<any>
  ) => {
    const startTime = performance.now();
    const cacheHit = this.isInCache(componentName);

    try {
      const result = await importFn();
      const loadTime = performance.now() - startTime;

      this.metrics.push({
        componentName,
        loadTime,
        cacheHit
      });

      // Report to analytics
      this.reportMetrics(componentName, loadTime, cacheHit);

      return result;
    } catch (error) {
      console.error(`Failed to load ${componentName}:`, error);
      throw error;
    }
  };

  private isInCache = (componentName: string): boolean => {
    // Check if module is already in module cache
    return Object.keys(window.__webpack_require__.cache || {})
      .some(key => key.includes(componentName));
  };

  private reportMetrics = (componentName: string, loadTime: number, cacheHit: boolean) => {
    // Send to analytics service
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', 'remote_component_load', {
        component_name: componentName,
        load_time: Math.round(loadTime),
        cache_hit: cacheHit
      });
    }
  };

  getMetrics = () => this.metrics;
}

export const bundleMonitor = new BundleMonitor();

// Usage
const RemoteApp = lazy(() =>
  bundleMonitor.trackComponentLoad('RemoteApp', () => import('remote/App'))
);
```

---

## üéØ 30-Second Quick Wins

### Instant Error Recovery
```tsx
// Add this to ANY existing lazy component - 2 lines of code
const RemoteApp = lazy(() =>
  import('remote/App').catch(() => ({ default: () => <div>Offline fallback</div> }))
);
```

### Smart Loading (No Flash)
```tsx
// Prevent loading flash on fast connections
const [showLoading, setShowLoading] = useState(false);
useEffect(() => {
  const timer = setTimeout(() => setShowLoading(true), 200);
  return () => clearTimeout(timer);
}, []);

// Only show loading after 200ms delay
<Suspense fallback={showLoading ? <LoadingSpinner /> : null}>
```

### Network Detection
```tsx
// One-liner network status
const isOnline = navigator.onLine;
return isOnline ? <RemoteApp /> : <div>You're offline</div>;
```

---

## üß™ Complete Production Example

```tsx
// components/ProductionRemoteLoader.tsx
import React, { Suspense, useMemo } from 'react';
import { RemoteErrorBoundary } from './RemoteErrorBoundary';
import { SmartSuspense } from './SmartSuspense';
import { useNetworkStatus } from '../hooks/useNetworkStatus';
import { createRemoteLoader } from '../utils/remoteLoader';
import { bundleMonitor } from '../utils/bundleMonitor';

interface ProductionRemoteLoaderProps {
  moduleName: string;
  importFn: () => Promise<any>;
  fallback?: React.ComponentType;
  enabled?: boolean;
  preload?: boolean;
}

export const ProductionRemoteLoader: React.FC<ProductionRemoteLoaderProps> = ({
  moduleName,
  importFn,
  fallback: FallbackComponent,
  enabled = true,
  preload = false
}) => {
  const { isOnline } = useNetworkStatus();

  const Component = useMemo(() => {
    if (!enabled || !isOnline) {
      return FallbackComponent || (() => <div>Component not available</div>);
    }

    const enhancedLoader = createRemoteLoader(
      () => bundleMonitor.trackComponentLoad(moduleName, importFn),
      3, // max retries
      1000 // base delay
    );

    return React.lazy(enhancedLoader);
  }, [enabled, isOnline, moduleName, importFn, FallbackComponent]);

  // Preload if requested
  React.useEffect(() => {
    if (preload && enabled && isOnline) {
      importFn().catch(() => {
        console.warn(`Failed to preload ${moduleName}`);
      });
    }
  }, [preload, enabled, isOnline, moduleName, importFn]);

  if (!enabled) {
    return FallbackComponent ? <FallbackComponent /> : null;
  }

  if (!isOnline) {
    return (
      <div className="offline-fallback">
        <p>This feature requires an internet connection</p>
      </div>
    );
  }

  return (
    <RemoteErrorBoundary
      onError={(error, errorInfo) => {
        console.error(`Error in ${moduleName}:`, error, errorInfo);
      }}
    >
      <SmartSuspense
        fallback={
          <div className="loading-remote">
            <div className="spinner" />
            <p>Loading {moduleName}...</p>
          </div>
        }
        minLoadingTime={200}
        timeout={15000}
      >
        <Component />
      </SmartSuspense>
    </RemoteErrorBoundary>
  );
};

// Usage
const App = () => (
  <div>
    <h1>Host Application</h1>

    <ProductionRemoteLoader
      moduleName="RemoteApp"
      importFn={() => import('remote/App')}
      enabled={true}
      preload={true}
      fallback={() => <div>Remote app is not available</div>}
    />

    <ProductionRemoteLoader
      moduleName="RemoteWidget"
      importFn={() => import('remote/Widget')}
      enabled={process.env.NODE_ENV === 'production'}
    />
  </div>
);
```

---

## ‚ö° Performance Best Practices

### 1. Loading State Optimization
```tsx
// Prevent loading flash for fast networks
const useDelayedFallback = (delay = 200) => {
  const [showFallback, setShowFallback] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => setShowFallback(true), delay);
    return () => clearTimeout(timer);
  }, [delay]);

  return showFallback;
};
```

### 2. Resource Hints
```tsx
// Add to document head
<link rel="dns-prefetch" href="//remote-domain.com" />
<link rel="preconnect" href="//remote-domain.com" />
<link rel="modulepreload" href="/remoteEntry.js" />
```

### 3. Error Recovery Strategies
```tsx
const ErrorRecoveryStrategies = {
  RETRY: 'retry',
  FALLBACK: 'fallback',
  GRACEFUL_DEGRADATION: 'graceful_degradation'
} as const;

const useErrorRecovery = (strategy = ErrorRecoveryStrategies.RETRY) => {
  // Implementation based on strategy
};
```

---

## üß™ Testing Remote Components

```tsx
// __tests__/RemoteComponent.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { ProductionRemoteLoader } from '../components/ProductionRemoteLoader';

// Mock remote import
const mockRemoteComponent = () => Promise.resolve({
  default: () => <div>Mocked Remote Component</div>
});

const mockFailingImport = () => Promise.reject(new Error('Network error'));

describe('ProductionRemoteLoader', () => {
  it('loads remote component successfully', async () => {
    render(
      <ProductionRemoteLoader
        moduleName="TestRemote"
        importFn={mockRemoteComponent}
      />
    );

    await waitFor(() => {
      expect(screen.getByText('Mocked Remote Component')).toBeInTheDocument();
    });
  });

  it('shows fallback on error', async () => {
    render(
      <ProductionRemoteLoader
        moduleName="TestRemote"
        importFn={mockFailingImport}
        fallback={() => <div>Fallback Component</div>}
      />
    );

    await waitFor(() => {
      expect(screen.getByText('Fallback Component')).toBeInTheDocument();
    });
  });

  it('respects enabled prop', () => {
    render(
      <ProductionRemoteLoader
        moduleName="TestRemote"
        importFn={mockRemoteComponent}
        enabled={false}
        fallback={() => <div>Disabled Fallback</div>}
      />
    );

    expect(screen.getByText('Disabled Fallback')).toBeInTheDocument();
  });
});
```

---

## üîç Key Concepts Summary

| Concept | Definition | Example |
|---------|------------|---------|
| **Retry Logic** | Automatic retry with exponential backoff | `createRemoteLoader(importFn, 3, 1000)` |
| **Preloading** | Load components before needed | `preloadRemoteModule('app', importFn)` |
| **Network Awareness** | Adapt loading based on connection | `useNetworkStatus()` hook |
| **Smart Fallbacks** | Graceful degradation strategies | Error boundaries with retry |
| **Performance Monitoring** | Track loading metrics | Bundle size and load time tracking |

---

## ‚úÖ Best Practices Checklist

- [ ] **Error Boundaries**: Wrap all remote components
- [ ] **Retry Logic**: Implement exponential backoff
- [ ] **Loading States**: Show meaningful loading indicators
- [ ] **Network Awareness**: Handle offline scenarios
- [ ] **Performance Monitoring**: Track loading metrics
- [ ] **Preloading**: Load critical components early
- [ ] **Fallback Components**: Provide graceful degradation
- [ ] **Testing**: Mock remote imports in tests

---

## üß™ Hands-On Exercise

**Challenge**: Enhance your 2.6 setup with advanced loading patterns

### Step 1: Add Error Recovery (5 minutes)
```tsx
// In your host app from 2.6, replace:
const RemoteApp = lazy(() => import('remote/App'));

// With this enhanced version:
const RemoteApp = lazy(() =>
  import('remote/App').catch(() => ({
    default: () => (
      <div style={{ border: '2px solid red', padding: '20px' }}>
        ‚ùå Remote component failed to load
        <button onClick={() => window.location.reload()}>Retry</button>
      </div>
    )
  }))
);
```

### Step 2: Test Error Scenarios
```bash
# Stop the remote server (Ctrl+C in remote terminal)
# Visit host app - should show error fallback instead of crash
# Restart remote server - click retry button to recover
```

### Step 3: Add Loading Enhancement
```tsx
// Replace basic Suspense with smart loading
const [showLoading, setShowLoading] = useState(false);
useEffect(() => {
  const timer = setTimeout(() => setShowLoading(true), 200);
  return () => clearTimeout(timer);
}, []);

<Suspense fallback={showLoading ? <div>Loading remote...</div> : null}>
  <RemoteApp />
</Suspense>
```

‚úÖ **Success Criteria**: Your app gracefully handles remote failures and has smooth loading states

---

## üìñ Learning Path & Next Steps

### ‚úÖ **Mastery Checklist - You Can Now:**

- [ ] Implement retry mechanisms for failed remote loads
- [ ] Create network-aware loading strategies
- [ ] Build smart error boundaries with recovery
- [ ] Optimize loading states to prevent UI flash
- [ ] Monitor and track remote component performance
- [ ] Implement preloading strategies for better UX
- [ ] Test remote components effectively

### üîú **Next Topic**: [2.8 Mounting Remote Apps into Host DOM](./2.8-mounting-remote-apps.md)

**What you'll learn**: Advanced mounting patterns, lifecycle management, and multi-remote orchestration

### üîÆ **Your Learning Journey**:

```
Basic Setup ‚Üí Advanced Loading (You are here!) ‚Üí DOM Mounting ‚Üí Production Deploy
```

---

## üöÄ Quick Reference Card

### Essential Patterns
```tsx
// Retry with backoff
const loader = createRemoteLoader(() => import('remote/App'), 3, 1000);

// Network-aware loading
const { isOnline } = useNetworkStatus();

// Smart error boundary
<RemoteErrorBoundary onError={handleError}>
  <Suspense fallback={<LoadingSpinner />}>
    <RemoteComponent />
  </Suspense>
</RemoteErrorBoundary>

// Preloading
preloadRemoteModule('app', () => import('remote/App'));
```

### Performance Monitoring
```tsx
// Track metrics
bundleMonitor.trackComponentLoad('App', () => import('remote/App'));

// Report to analytics
window.gtag('event', 'remote_load', {
  component: 'App',
  load_time: 1250
});
```

---

## üìö References

- [React.lazy Documentation](https://react.dev/reference/react/lazy)
- [Suspense API Reference](https://react.dev/reference/react/Suspense)
- [Error Boundaries Guide](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
- [Performance Monitoring Best Practices](https://web.dev/performance-monitoring/)