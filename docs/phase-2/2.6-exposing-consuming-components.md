# 2.6 Exposing & Consuming Components in Micro-Frontends

## Overview

In Micro-Frontend architecture using Webpack Module Federation, the remote app "exposes" components, and the host app "consumes" them. This enables independent development and deployment while sharing UI and logic at runtime.

---

## 1. Exposing Components (Remote)

In the remote app's `webpack.config.js`:

```js
new ModuleFederationPlugin({
  name: 'remote',
  filename: 'remoteEntry.js',
  exposes: {
    './App': './src/App', // Expose App component
    // You can expose more components here
  },
  shared: { react: { singleton: true }, 'react-dom': { singleton: true } },
});
```

- The `exposes` field makes `App` available to the host.
- The remote's `App.tsx` is a standard React component:

```tsx
// remote/src/App.tsx
const App = () => (
  <div>
    <h1>ðŸš€ Remote App</h1>
    <p>This is a standalone React TypeScript app!</p>
    <p>Later, this will be consumed by the host app.</p>
  </div>
);
export default App;
```

---

## 2. Consuming Components (Host)

In the host app's `webpack.config.js`:

```js
new ModuleFederationPlugin({
  name: 'host',
  remotes: {
    remote: 'remote@http://localhost:3001/remoteEntry.js',
  },
  shared: { react: { singleton: true }, 'react-dom': { singleton: true } },
});
```

In the host's `App.tsx`:

```tsx
import { Suspense, lazy } from 'react';
const RemoteApp = lazy(() => import('remote/App'));

const App = () => (
  <div>
    <h1>ðŸš€ Host App</h1>
    <p>This is a standalone React TypeScript app!</p>
    <Suspense fallback={<div>Loading remote app...</div>}>
      <RemoteApp />
    </Suspense>
  </div>
);
export default App;
```

- The host uses `React.lazy` and `Suspense` to load the remote component at runtime.
- The remote component is rendered inside the host's DOM, just like any local React component.

---

## 3. How It Works

1. Remote exposes components via `exposes` in its webpack config.
2. Host declares the remote in its `remotes` config.
3. Host imports the remote component using dynamic import (`React.lazy`).
4. Webpack Module Federation loads the remote code at runtime.
5. Host renders the remote component in its UI.

---

## 4. Why This Matters

- Enables true code sharing between independently deployed apps.
- Teams can work on remotes and hosts separately.
- Host can consume new features from remote without redeploying itself.

---

## 5. Best Practices

- Use clear naming for exposed modules.
- Document the API and props of exposed components.
- Handle loading and error states in the host.
- Align shared dependencies (React, etc.) for compatibility.

---

## What is ModuleFederationPlugin?

`ModuleFederationPlugin` is a Webpack plugin that enables runtime sharing of modules between separate builds (host and remote). It is the core of Webpack's Module Federation feature.

### Key Properties Explained

```js
new ModuleFederationPlugin({
  name: 'remote', // Unique name for this remote. Must match in host's remotes config. Pitfall: Name collision or mismatch will break federation.
  filename: 'remoteEntry.js', // Output file for remote's manifest. Pitfall: Must be unique per remote; avoid overwriting or misnaming.
  exposes: {
    './App': './src/App', // Key is module name exposed to host; value is local path. Pitfall: Path must exist and be correct; typos cause runtime errors.
    // You can expose more components here
  },
  shared: {
    react: { singleton: true }, // Ensures only one React instance is loaded. Pitfall: Version mismatch between host/remote can cause hooks/context bugs.
    'react-dom': { singleton: true }, // Same for react-dom.
  },
});

/**
 * Deep Dive: ModuleFederationPlugin Properties
 *
 * - name: Unique identifier for this app in federation. Must be consistent across host/remote configs. Avoid using generic names.
 * - filename: The file where federation manifest is emitted. Should be unique and served by your dev/prod server. If not accessible, host cannot load remote.
 * - exposes: Object mapping module names (keys) to local file paths (values). These are what the host can import. Paths must be valid and exported correctly.
 * - shared: Dependencies to share between host/remote. Use singleton for libraries like React to avoid multiple instances. Specify requiredVersion for stricter matching. Pitfall: If versions differ, runtime errors or duplicate React instances may occur.
 *
 * Common Pitfalls:
 * - Mismatched names between host/remote configs.
 * - Incorrect or missing exposed paths.
 * - Not serving remoteEntry.js correctly (check dev server config).
 * - Shared dependencies with incompatible versions.
 * - Forgetting to export components in exposed files.
 * - Not using singleton for React/ReactDOM (can break context/hooks).
 * - Overlapping filenames for remoteEntry.js in multi-remote setups.
 */
```

---

## Common Pitfalls & Solutions

| Property | Pitfall                          | Solution                                                                                                                                                                                                                                                                                                                                                 |
| -------- | -------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name     | Mismatch between host/remote     | Use same name in both configs                                                                                                                                                                                                                                                                                                                            |
| filename | Wrong filename or path           | Ensure host points to correct remoteEntry                                                                                                                                                                                                                                                                                                                |
| exposes  | Typo or missing file             | Double-check paths and exports                                                                                                                                                                                                                                                                                                                           |
| remotes  | Wrong remote name or URL         | Match names and use correct URLs                                                                                                                                                                                                                                                                                                                         |
| shared   | Not singleton for React/ReactDOM | Always set singleton: true                                                                                                                                                                                                                                                                                                                               |
| shared   | Version mismatch                 | Align versions in both apps; mismatched React versions can cause context, hooks, and rendering bugs. If versions differ, you may see errors like 'Invalid hook call', broken context, or duplicate React instances. Always use the same major/minor React version in both host and remote, and set `requiredVersion` for stricter enforcement.           |
| shared   | Legacy/isolated React versions   | If you cannot align versions (e.g., legacy apps), avoid sharing React as singleton. Instead, isolate remotes (each loads its own React), use custom elements/web components for integration, and do not share state/context/hooks across boundaries. Accept that you lose seamless React interop and may need to communicate via props, events, or APIs. |
| shared   | Missing dependency               | Add all shared libraries to both configs                                                                                                                                                                                                                                                                                                                 |

---

## Example: Host & Remote Configs

### Remote (`webpack.config.js`)

```js
new ModuleFederationPlugin({
  name: 'remote',
  filename: 'remoteEntry.js',
  exposes: {
    './App': './src/App',
  },
  shared: { react: { singleton: true }, 'react-dom': { singleton: true } },
});
```

### Host (`webpack.config.js`)

```js
new ModuleFederationPlugin({
  name: 'host',
  remotes: {
    remote: 'remote@http://localhost:3001/remoteEntry.js',
  },
  shared: { react: { singleton: true }, 'react-dom': { singleton: true } },
});
```

---

## References

- [Webpack Module Federation Docs](https://webpack.js.org/concepts/module-federation/)
- [Micro-Frontend Communication Patterns](https://micro-frontends.org/)
