# 2.9 Dynamic Imports vs Static Imports

> **What you'll learn**: Performance optimization strategies, import timing decisions, and bundle splitting techniques for micro-frontend applications
> 📊 **Difficulty**: Intermediate | 🛠️ **Prerequisites**: 2.8 App Mounting Patterns

## 🎯 Quick Start: The Import Decision

### The Performance Problem
```tsx
// ❌ Static imports - loads everything upfront
import RemoteEcommerce from 'remote/EcommerceApp';
import RemoteAnalytics from 'remote/AnalyticsApp';
import RemoteProfile from 'remote/ProfileApp';

const Dashboard = () => (
  <div>
    {/* All remote apps loaded even if not visible */}
    <RemoteEcommerce />
    <RemoteAnalytics />
    <RemoteProfile />
  </div>
);

// Problem:
// - Downloads all remote code immediately
// - Blocks initial page render
// - Wastes bandwidth on unused features
// - Poor Core Web Vitals scores
```

### ✅ Strategic Import Decisions
```tsx
// ✅ Mix of static and dynamic based on usage patterns
import RemoteHeader from 'remote/Header'; // Static - always needed

const Dashboard = () => {
  // Dynamic - load on demand
  const EcommerceApp = lazy(() => import('remote/EcommerceApp'));
  const AnalyticsApp = lazy(() => import('remote/AnalyticsApp'));

  return (
    <div>
      <RemoteHeader /> {/* Immediate load */}

      <Suspense fallback={<div>Loading store...</div>}>
        <EcommerceApp /> {/* Load when needed */}
      </Suspense>

      <Suspense fallback={<div>Loading analytics...</div>}>
        <AnalyticsApp /> {/* Load when needed */}
      </Suspense>
    </div>
  );
};
```

✅ **Test It Works**:
```bash
# 1. Open browser DevTools → Network tab
# 2. Visit your app and see only essential bundles load initially
# 3. Watch additional chunks load as you interact with features
# 4. Check Performance tab - faster initial load times

# Performance validation:
lighthouse http://localhost:3000 --only-categories=performance
# Should show improved First Contentful Paint and Largest Contentful Paint
```

---

## 🤔 Import Strategy Concepts

**What**: Choosing between immediate loading (static) and on-demand loading (dynamic) for remote modules
**Why**: Optimizes performance, reduces bundle size, and improves user experience
**When**: Critical decision for any production micro-frontend architecture

**Core Decision Framework**:
- **Critical Path**: What's essential for first page render?
- **User Behavior**: What features do users actually use?
- **Network Impact**: How much bandwidth does each remote consume?
- **Performance Budget**: What's your acceptable loading time?

## 📊 Static vs Dynamic Comparison

### Static Imports

**Concept**: Import remote modules at build time, making them part of the initial bundle.

**What static imports do**:
- Load remote modules immediately when the host app starts
- Bundle remote code with host application
- Create direct dependencies between host and remote
- Enable tree shaking and dead code elimination

**When to use static imports**:
- **Critical UI components**: Headers, navigation, essential layout elements
- **Always visible features**: Components that appear on every page
- **Small, lightweight remotes**: When bundle size impact is minimal
- **High-frequency usage**: Features used by >80% of users immediately

**Performance characteristics**:
- **Pros**: No loading delay when component is needed, better for critical path
- **Cons**: Increases initial bundle size, slower app startup time

```tsx
// Static import examples - immediate loading
import RemoteHeader from 'remote/Header';        // Always visible
import RemoteNavigation from 'remote/Navigation'; // Core navigation
import RemoteFooter from 'remote/Footer';         // Always present

const Layout = ({ children }) => (
  <div>
    <RemoteHeader />     {/* Loads immediately */}
    <RemoteNavigation /> {/* Loads immediately */}
    <main>{children}</main>
    <RemoteFooter />     {/* Loads immediately */}
  </div>
);
```

### Dynamic Imports

**Concept**: Load remote modules on-demand using React.lazy and dynamic import() syntax.

**What dynamic imports do**:
- Load remote modules only when actually needed
- Split code into separate chunks that load asynchronously
- Enable progressive loading based on user interactions
- Reduce initial bundle size and improve startup performance

**When to use dynamic imports**:
- **Secondary features**: Admin panels, advanced settings, reporting tools
- **Route-based components**: Full page applications loaded per route
- **Large dependencies**: Heavy remotes that impact startup performance
- **Conditional features**: Components shown based on user permissions/plans

**Performance characteristics**:
- **Pros**: Faster initial load, smaller bundles, better Core Web Vitals
- **Cons**: Loading delay when first accessed, requires loading state management

```tsx
// Dynamic import examples - load on demand
const AdminPanel = lazy(() => import('remote/AdminPanel'));
const ReportsApp = lazy(() => import('remote/ReportsApp'));
const AdvancedSettings = lazy(() => import('remote/AdvancedSettings'));

const ConditionalFeatures = ({ userRole, activeTab }) => (
  <div>
    {activeTab === 'admin' && userRole === 'admin' && (
      <Suspense fallback={<div>Loading admin panel...</div>}>
        <AdminPanel />
      </Suspense>
    )}

    {activeTab === 'reports' && (
      <Suspense fallback={<div>Loading reports...</div>}>
        <ReportsApp />
      </Suspense>
    )}
  </div>
);
```

---

## 🎯 30-Second Quick Wins

### Instant Route Splitting (Quick)
```tsx
// Convert any static route to dynamic - 3 lines
const ShoppingApp = lazy(() => import('remote/ShoppingApp'));

<Route path="/shop/*" element={
  <Suspense fallback={<div>Loading shop...</div>}>
    <ShoppingApp />
  </Suspense>
} />
// ✅ Result: Shop bundle only loads when user visits /shop
// ✅ Benefit: 30-50% smaller initial bundle size
```

### Conditional Loading (Simple)
```tsx
// Never load unused features - 1 condition
{user.isAdmin && (
  <Suspense fallback={<div>Loading admin...</div>}>
    <AdminTools />
  </Suspense>
)}
// ✅ Result: Admin bundle never downloads for regular users
// ✅ Benefit: Saves bandwidth and improves performance
```

### Smart Preloading (Simple)
```tsx
// Load before user clicks - 1 event handler
const preloadReports = () => import('remote/ReportsApp');

<button
  onMouseEnter={preloadReports} // Start loading on hover
  onClick={() => setShowReports(true)}
>
  View Reports
</button>
// ✅ Result: Instant loading when clicked after hover
// ✅ Benefit: Feels like static import but with dynamic benefits
```

### Performance Tracking (Detailed)
```tsx
// See your optimization impact - copy this function
const trackImport = (moduleName: string) => {
  const startTime = performance.now();
  return import(`remote/${moduleName}`).then(module => {
    const loadTime = performance.now() - startTime;
    console.log(`📦 ${moduleName}: ${loadTime.toFixed(2)}ms`);
    return module;
  });
};

const ReportsApp = lazy(() => trackImport('ReportsApp'));
// ✅ Result: Console shows exact load times for each remote
// ✅ Benefit: Data-driven optimization decisions
```

---

## ⚡ Performance Optimization Strategies

### 1. Critical Path Analysis

**Concept**: Identify which remote modules are essential for the initial user experience.

**How to analyze your critical path**:
1. **User Journey Mapping**: What do users see and interact with first?
2. **Analytics Review**: Which features have >80% usage in first 30 seconds?
3. **Performance Audit**: Which imports block initial render?
4. **Bundle Analysis**: What's the size impact of each remote?

**Critical Path Decision Tree**:
```
Is the component visible immediately?
├─ Yes → Is it <50KB?
│  ├─ Yes → Use Static Import ✅
│  └─ No → Use Dynamic Import with preloading
└─ No → Is it used by >80% of users?
   ├─ Yes → Use Dynamic Import with preloading
   └─ No → Use Dynamic Import on-demand ✅
```

**Implementation**:
```tsx
// Critical path optimization
const CriticalPathApp = () => {
  return (
    <div>
      {/* Static: Always visible, small, essential */}
      <RemoteHeader />
      <RemoteNavigation />

      {/* Dynamic: Below fold, conditional */}
      <Suspense fallback={<SkeletonLoader />}>
        <LazyMainContent />
      </Suspense>

      {/* Dynamic: Admin only */}
      {user.isAdmin && (
        <Suspense fallback={<div>Loading admin...</div>}>
          <LazyAdminPanel />
        </Suspense>
      )}
    </div>
  );
};
```

### 2. Intelligent Preloading

**Concept**: Start loading components before users need them based on behavior prediction.

**Preloading Strategies**:
- **Intersection Observer**: Load when scrolling into view
- **Hover Intent**: Start loading on mouse hover
- **Time-based**: Load after initial page is interactive
- **Route Prediction**: Preload likely next pages

```tsx
// hooks/useIntelligentPreload.ts
import { useEffect } from 'react';

export const useIntelligentPreload = (
  importFn: () => Promise<any>,
  trigger: 'hover' | 'visible' | 'idle' | 'immediate'
) => {
  useEffect(() => {
    let timeoutId: NodeJS.Timeout;

    switch (trigger) {
      case 'immediate':
        importFn();
        break;

      case 'idle':
        // Load when browser is idle
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => importFn());
        } else {
          timeoutId = setTimeout(() => importFn(), 2000);
        }
        break;

      case 'visible':
        // Load when element comes into view
        const observer = new IntersectionObserver((entries) => {
          if (entries[0].isIntersecting) {
            importFn();
            observer.disconnect();
          }
        });

        // Observer setup would happen in component
        break;
    }

    return () => {
      if (timeoutId) clearTimeout(timeoutId);
    };
  }, [importFn, trigger]);
};

// Usage examples
const ShoppingSection = () => {
  const preloadShop = useIntelligentPreload(
    () => import('remote/ShoppingApp'),
    'idle' // Load when browser is idle
  );

  return (
    <section>
      <h2>Shopping</h2>
      <button
        onMouseEnter={() => import('remote/ShoppingApp')} // Hover preload
        onClick={() => setShowShop(true)}
      >
        Open Shop
      </button>
    </section>
  );
};
```

### 3. Bundle Splitting Strategies

**Concept**: Optimize how remote code is divided into loadable chunks.

**Splitting Approaches**:
- **Route-based**: Each major route gets its own chunk
- **Feature-based**: Each feature area gets its own chunk
- **User-based**: Different chunks for different user types
- **Vendor-based**: Separate chunks for third-party dependencies

```tsx
// Advanced bundle splitting patterns

// 1. Route-based splitting
const routes = [
  {
    path: '/shop/*',
    component: lazy(() => import('remote/ShoppingApp')),
    preload: 'idle'
  },
  {
    path: '/admin/*',
    component: lazy(() => import('remote/AdminApp')),
    preload: 'never' // Only load when accessed
  },
  {
    path: '/reports/*',
    component: lazy(() => import('remote/ReportsApp')),
    preload: 'hover' // Load on navigation hover
  }
];

// 2. Feature-based splitting
const FeatureLoader = ({ feature, children }) => {
  const FeatureComponent = lazy(() =>
    import(`remote/${feature}App`)
      .catch(() => ({ default: () => <div>Feature unavailable</div> }))
  );

  return (
    <Suspense fallback={<FeatureLoadingSkeleton feature={feature} />}>
      <FeatureComponent>{children}</FeatureComponent>
    </Suspense>
  );
};

// 3. User-role-based splitting
const RoleBasedLoader = ({ userRole, children }) => {
  const imports = {
    admin: () => import('remote/AdminDashboard'),
    user: () => import('remote/UserDashboard'),
    guest: () => import('remote/GuestDashboard')
  };

  const DashboardComponent = lazy(imports[userRole] || imports.guest);

  return (
    <Suspense fallback={<DashboardSkeleton />}>
      <DashboardComponent>{children}</DashboardComponent>
    </Suspense>
  );
};
```

---

## 📈 Performance Monitoring

### 1. Bundle Analysis Tools

**Concept**: Measure and track the impact of your import decisions.

```tsx
// utils/bundleAnalyzer.ts
class BundleAnalyzer {
  private metrics = new Map<string, number>();

  trackImport = async (moduleName: string, importFn: () => Promise<any>) => {
    const startTime = performance.now();
    const startBytes = this.getNetworkBytes();

    try {
      const module = await importFn();
      const loadTime = performance.now() - startTime;
      const bytesLoaded = this.getNetworkBytes() - startBytes;

      this.metrics.set(moduleName, { loadTime, bytesLoaded });

      // Report to analytics
      this.reportMetrics(moduleName, loadTime, bytesLoaded);

      return module;
    } catch (error) {
      console.error(`Failed to load ${moduleName}:`, error);
      throw error;
    }
  };

  private getNetworkBytes = () => {
    if ('connection' in navigator) {
      return (navigator as any).connection?.transferSize || 0;
    }
    return 0;
  };

  private reportMetrics = (moduleName: string, loadTime: number, bytes: number) => {
    // Send to your analytics service
    if (typeof gtag !== 'undefined') {
      gtag('event', 'remote_module_load', {
        module_name: moduleName,
        load_time: Math.round(loadTime),
        bytes_loaded: bytes,
        user_agent: navigator.userAgent
      });
    }
  };

  getReport = () => {
    const report = Array.from(this.metrics.entries()).map(([name, metrics]) => ({
      module: name,
      ...metrics
    }));

    return {
      modules: report,
      totalLoadTime: report.reduce((sum, m) => sum + m.loadTime, 0),
      totalBytes: report.reduce((sum, m) => sum + m.bytesLoaded, 0)
    };
  };
}

export const bundleAnalyzer = new BundleAnalyzer();

// Usage
const ReportsApp = lazy(() =>
  bundleAnalyzer.trackImport('ReportsApp', () => import('remote/ReportsApp'))
);
```

### 2. Core Web Vitals Optimization

**Concept**: Optimize import strategies to improve Google's Core Web Vitals scores.

```tsx
// utils/webVitalsOptimizer.ts
class WebVitalsOptimizer {
  private fcpThreshold = 1800; // First Contentful Paint target (ms)
  private lcpThreshold = 2500; // Largest Contentful Paint target (ms)

  optimizeForFCP = () => {
    // Delay non-critical imports until after FCP
    return new Promise(resolve => {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', resolve);
      } else {
        // Use requestIdleCallback or setTimeout
        if ('requestIdleCallback' in window) {
          requestIdleCallback(resolve);
        } else {
          setTimeout(resolve, 0);
        }
      }
    });
  };

  optimizeForLCP = () => {
    // Ensure critical content loads before LCP threshold
    return new Promise(resolve => {
      const startTime = performance.now();

      const checkLCP = () => {
        const currentTime = performance.now();
        if (currentTime - startTime < this.lcpThreshold) {
          resolve(true);
        } else {
          // Delay non-critical loads
          setTimeout(resolve, 100);
        }
      };

      // Check if we're within LCP budget
      requestAnimationFrame(checkLCP);
    });
  };

  createOptimizedLoader = (priority: 'critical' | 'important' | 'lazy') => {
    return async (importFn: () => Promise<any>) => {
      switch (priority) {
        case 'critical':
          // Load immediately
          return importFn();

        case 'important':
          // Load after FCP
          await this.optimizeForFCP();
          return importFn();

        case 'lazy':
          // Load after LCP window
          await this.optimizeForLCP();
          return importFn();
      }
    };
  };
}

export const webVitalsOptimizer = new WebVitalsOptimizer();

// Usage with different priorities
const CriticalHeader = lazy(() =>
  webVitalsOptimizer.createOptimizedLoader('critical')(() => import('remote/Header'))
);

const ImportantDashboard = lazy(() =>
  webVitalsOptimizer.createOptimizedLoader('important')(() => import('remote/Dashboard'))
);

const LazyReports = lazy(() =>
  webVitalsOptimizer.createOptimizedLoader('lazy')(() => import('remote/Reports'))
);
```

---

## 🧪 Complete Production Example

```tsx
// components/OptimizedApp.tsx
import React, { Suspense, lazy, useState, useEffect } from 'react';
import { bundleAnalyzer } from '../utils/bundleAnalyzer';
import { webVitalsOptimizer } from '../utils/webVitalsOptimizer';

// Static imports for critical path
import RemoteHeader from 'remote/Header';
import RemoteNavigation from 'remote/Navigation';

// Dynamic imports with different strategies
const ShoppingApp = lazy(() =>
  bundleAnalyzer.trackImport('Shopping', () => import('remote/ShoppingApp'))
);

const AdminPanel = lazy(() =>
  webVitalsOptimizer.createOptimizedLoader('lazy')(() => import('remote/AdminPanel'))
);

const ReportsApp = lazy(() => {
  // Preload on hover strategy
  return new Promise(resolve => {
    import('remote/ReportsApp').then(resolve);
  });
});

const OptimizedApp = () => {
  const [activeTab, setActiveTab] = useState('home');
  const [user, setUser] = useState({ role: 'user' });
  const [preloadedModules, setPreloadedModules] = useState(new Set());

  // Intelligent preloading
  const preloadModule = (moduleName: string) => {
    if (!preloadedModules.has(moduleName)) {
      switch (moduleName) {
        case 'shopping':
          import('remote/ShoppingApp');
          break;
        case 'reports':
          import('remote/ReportsApp');
          break;
        case 'admin':
          if (user.role === 'admin') {
            import('remote/AdminPanel');
          }
          break;
      }
      setPreloadedModules(prev => new Set([...prev, moduleName]));
    }
  };

  // Preload based on user behavior
  useEffect(() => {
    // Load important modules after initial page load
    const timer = setTimeout(() => {
      if (user.role === 'admin') {
        preloadModule('admin');
      }
      preloadModule('shopping');
    }, 2000);

    return () => clearTimeout(timer);
  }, [user.role]);

  return (
    <div className="optimized-app">
      {/* Critical path - static imports */}
      <RemoteHeader />
      <RemoteNavigation
        activeTab={activeTab}
        onTabChange={setActiveTab}
        onTabHover={preloadModule} // Preload on hover
      />

      {/* Content area with optimized loading */}
      <main>
        {activeTab === 'home' && (
          <div>
            <h1>Welcome</h1>
            {/* Preload shopping module when home is visible */}
            <div
              onMouseEnter={() => preloadModule('shopping')}
              style={{ padding: '20px', cursor: 'pointer' }}
              onClick={() => setActiveTab('shopping')}
            >
              <h2>Visit Our Store</h2>
              <p>Hover to preload, click to visit</p>
            </div>
          </div>
        )}

        {activeTab === 'shopping' && (
          <Suspense fallback={
            <div className="loading-skeleton">
              <div>Loading shopping experience...</div>
              <div>This may take a moment on first visit</div>
            </div>
          }>
            <ShoppingApp />
          </Suspense>
        )}

        {activeTab === 'reports' && (
          <Suspense fallback={<div>Loading reports...</div>}>
            <ReportsApp />
          </Suspense>
        )}

        {activeTab === 'admin' && user.role === 'admin' && (
          <Suspense fallback={<div>Loading admin panel...</div>}>
            <AdminPanel />
          </Suspense>
        )}
      </main>

      {/* Performance monitoring */}
      <PerformanceMonitor />
    </div>
  );
};

const PerformanceMonitor = () => {
  useEffect(() => {
    // Report bundle analysis after 10 seconds
    const timer = setTimeout(() => {
      const report = bundleAnalyzer.getReport();
      console.log('📊 Bundle Performance Report:', report);

      // Send to analytics
      if (typeof gtag !== 'undefined') {
        gtag('event', 'bundle_performance', {
          total_modules: report.modules.length,
          total_load_time: report.totalLoadTime,
          total_bytes: report.totalBytes
        });
      }
    }, 10000);

    return () => clearTimeout(timer);
  }, []);

  return null;
};

export default OptimizedApp;
```

---

## 🧪 Hands-On Exercise

**Challenge**: Optimize your existing micro-frontend setup with strategic import decisions

### Step 1: Audit Current Imports
```bash
# Analyze your current bundle
npm run build
npx webpack-bundle-analyzer build/static/js/*.js

# Look for:
# - Largest chunks (candidates for dynamic imports)
# - Unused code (remove or make conditional)
# - Vendor libraries loaded unnecessarily
```

### Step 2: Implement Route-Based Splitting
```tsx
// Replace static route components with dynamic ones
// Before:
import ShoppingApp from 'remote/ShoppingApp';

// After:
const ShoppingApp = lazy(() => import('remote/ShoppingApp'));

<Route path="/shop/*" element={
  <Suspense fallback={<ShopLoadingSkeleton />}>
    <ShoppingApp />
  </Suspense>
} />
```

### Step 3: Add Performance Monitoring
```tsx
// Track loading performance
const trackLoad = (name: string) => {
  const start = performance.now();
  return import(`remote/${name}`).then(module => {
    console.log(`${name} loaded in ${performance.now() - start}ms`);
    return module;
  });
};

const Reports = lazy(() => trackLoad('ReportsApp'));
```

### Step 4: Verify Improvements
```bash
# Build and measure impact
npm run build

# Compare bundle sizes
ls -lh build/static/js/ # Look for smaller main chunk, more smaller chunks

# Test loading behavior
npm start
# Open DevTools → Network → Reload page
# Should see: Smaller initial load, chunks appearing on route changes

# Performance audit
lighthouse http://localhost:3000 --only-categories=performance --output=json
# Target scores: Performance >90, FCP <1.8s, LCP <2.5s

# Advanced measurement
npx webpack-bundle-analyzer build/static/js/*.js
# Visualize bundle sizes and optimization opportunities
```

✅ **Success Criteria**:
- Initial bundle size reduced by 30%+
- First Contentful Paint <1.8 seconds
- Chunks load only when accessed
- Network tab shows intelligent loading patterns
- No functionality broken or loading errors

### Quick Validation Commands
```bash
# Check bundle reduction
du -sh build/static/js/main.*.js # Should be smaller
ls build/static/js/*.chunk.js | wc -l # Should see more chunks

# Test dynamic loading
curl -s http://localhost:3000 | grep -o "main\.[a-z0-9]*\.js" | head -1
# Should show smaller main bundle than before optimization
```

---

## ⚠️ Common Pitfalls & Solutions

### Problem: "ChunkLoadError: Loading chunk failed"

**Cause**: Dynamic import fails due to network issues or outdated chunks
**Solution**:
```tsx
// ❌ Fragile: No error handling
const Reports = lazy(() => import('remote/Reports'));

// ✅ Robust: Retry mechanism with fallback
const Reports = lazy(() =>
  import('remote/Reports')
    .catch(() => {
      // Retry once after 1 second
      return new Promise(resolve =>
        setTimeout(() => resolve(import('remote/Reports')), 1000)
      );
    })
    .catch(() => ({
      default: () => <div>Reports temporarily unavailable</div>
    }))
);
```

### Problem: "Waterfall loading" causing slow UX

**Cause**: Loading components in sequence instead of parallel
**Solution**:
```tsx
// ❌ Bad: Sequential loading (slow)
const loadDashboard = async () => {
  const charts = await import('remote/Charts');
  const tables = await import('remote/Tables');
  const filters = await import('remote/Filters');
};

// ✅ Good: Parallel loading (fast)
const loadDashboard = async () => {
  const [charts, tables, filters] = await Promise.all([
    import('remote/Charts'),
    import('remote/Tables'),
    import('remote/Filters')
  ]);
};
```

### Problem: Over-aggressive dynamic imports hurting UX

**Cause**: Making everything dynamic, even critical components
**Solution**:
```tsx
// ❌ Bad: Critical components made dynamic
const Header = lazy(() => import('remote/Header')); // User sees blank page

// ✅ Good: Critical components stay static
import Header from 'remote/Header'; // Immediate render
const AdminPanel = lazy(() => import('remote/AdminPanel')); // Non-critical
```

### Problem: Memory leaks from failed preloads

**Cause**: Preloading creates module references that aren't cleaned up
**Solution**:
```tsx
// ❌ Bad: Uncontrolled preloading
const preloadAll = () => {
  import('remote/Feature1');
  import('remote/Feature2');
  import('remote/Feature3');
  // Modules stay in memory even if never used
};

// ✅ Good: Controlled preloading with cleanup
const useControlledPreload = (moduleName: string) => {
  const [preloaded, setPreloaded] = useState(false);

  const preload = useCallback(() => {
    if (!preloaded) {
      import(`remote/${moduleName}`)
        .then(() => setPreloaded(true))
        .catch(() => {/* Handle error */});
    }
  }, [moduleName, preloaded]);

  return preload;
};
```

### Problem: No loading feedback for slow connections

**Cause**: Generic loading states that don't help users
**Solution**:
```tsx
// ❌ Bad: Generic loading message
<Suspense fallback={<div>Loading...</div>}>

// ✅ Good: Informative loading states
<Suspense fallback={
  <div className="loading-container">
    <div className="spinner" />
    <h3>Loading Shopping Experience</h3>
    <p>This may take a moment on first visit...</p>
    <div className="progress-indicator">
      <div className="progress-bar" />
    </div>
  </div>
}>
  <ShoppingApp />
</Suspense>
```

### Problem: Bundle analyzer shows duplicate dependencies

**Cause**: Multiple remotes loading the same libraries
**Solution**:
```tsx
// ✅ Configure shared dependencies properly
// In all webpack configs (host + remotes):
shared: {
  react: { singleton: true },
  'react-dom': { singleton: true },
  lodash: { singleton: true }, // Share common utilities
  '@mui/material': { singleton: true }, // Share UI libraries
}

// Check for duplicates:
// npx webpack-bundle-analyzer build/static/js/*.js
// Look for duplicate library entries
```

---

## ✅ Best Practices Checklist

- [ ] **Critical Path Analysis**: Identify what must load immediately
- [ ] **Route-Based Splitting**: Dynamic imports for each major route
- [ ] **Preloading Strategy**: Intelligent loading based on user behavior
- [ ] **Performance Monitoring**: Track bundle sizes and load times
- [ ] **Loading States**: Meaningful feedback during dynamic loads
- [ ] **Error Boundaries**: Graceful fallbacks for failed imports
- [ ] **Bundle Analysis**: Regular audits of what's being loaded
- [ ] **Core Web Vitals**: Optimize for Google's performance metrics

---

## 🔍 Key Concepts Summary

| Concept | Definition | Example |
|---------|------------|---------|
| **Static Import** | Load immediately at startup | `import Header from 'remote/Header'` |
| **Dynamic Import** | Load on-demand with React.lazy | `lazy(() => import('remote/Dashboard'))` |
| **Critical Path** | Essential code for first render | Navigation, headers, above-fold content |
| **Bundle Splitting** | Dividing code into loadable chunks | Route-based, feature-based, user-based |
| **Preloading** | Loading before user needs it | Hover intent, intersection observer |
| **Performance Budget** | Acceptable loading time limits | <1.8s FCP, <2.5s LCP targets |

---

## 📖 Learning Path & Next Steps

### ✅ **Mastery Checklist - You Can Now:**

- [ ] Choose between static and dynamic imports strategically
- [ ] Implement route-based code splitting for better performance
- [ ] Use intelligent preloading to optimize user experience
- [ ] Monitor and measure bundle performance impact
- [ ] Optimize for Core Web Vitals metrics
- [ ] Implement advanced bundle splitting strategies
- [ ] Handle loading states and error scenarios gracefully

### 🔜 **Next Topic**: [2.10 Lazy Loading and Code Splitting in MFEs](./2.10-lazy-loading-code-splitting.md)

**What you'll learn**: Advanced lazy loading patterns, sophisticated code splitting techniques, and production optimization strategies

### 🔮 **Your Learning Journey**:

```
Basic Setup → Advanced Loading → App Mounting → Import Optimization (You are here!) → Advanced Optimization
```

---

## 🚀 Quick Reference Card

### Decision Matrix
```tsx
// Critical path (static)
import Header from 'remote/Header';

// Route-based (dynamic)
const ShopApp = lazy(() => import('remote/ShopApp'));

// Conditional (dynamic)
{isAdmin && <Suspense><AdminPanel /></Suspense>}

// Preloaded (dynamic + strategy)
const Reports = lazy(() => preloadOnHover('remote/Reports'));
```

### Performance Patterns
```tsx
// Bundle tracking
const trackImport = (name) => {
  const start = performance.now();
  return import(`remote/${name}`).then(module => {
    console.log(`${name}: ${performance.now() - start}ms`);
    return module;
  });
};

// Parallel loading
Promise.all([
  import('remote/Charts'),
  import('remote/Tables')
]);

// Smart preloading
onMouseEnter={() => import('remote/Feature')}
```

---

## 📚 References

- [React.lazy Documentation](https://react.dev/reference/react/lazy)
- [Web Performance Metrics](https://web.dev/metrics/)
- [Bundle Splitting Guide](https://webpack.js.org/guides/code-splitting/)
- [Core Web Vitals](https://web.dev/vitals/)