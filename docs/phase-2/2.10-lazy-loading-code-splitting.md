# 2.10 Lazy Loading and Code Splitting in MFEs

> **What you'll learn**: Advanced lazy loading patterns, sophisticated code splitting techniques, and production optimization strategies for micro-frontend applications
> 📊 **Difficulty**: Advanced | 🛠️ **Prerequisites**: 2.9 Dynamic vs Static Imports

## 🎯 Quick Start: Beyond Basic Lazy Loading

### Why Basic Lazy Loading Fails at Scale

**The Problem**: As micro-frontends grow, basic `React.lazy()` becomes insufficient:

```tsx
// ❌ Basic approach - works for small apps but breaks down
const AdminPanel = lazy(() => import('remote/AdminPanel'));
const Reports = lazy(() => import('remote/Reports'));
const Analytics = lazy(() => import('remote/Analytics'));

// Scale problems this creates:
// 1. Critical features compete with optional ones for bandwidth
// 2. Users wait for low-priority content while essential UI blocks
// 3. Network waterfalls prevent parallel optimization
// 4. No intelligence about user behavior or device capabilities
// 5. Bundle size grows without strategy or limits
```

### ✅ Production-Ready Solution: Smart Lazy Loading

**The Strategy**: Prioritize, predict, and optimize loading based on real user needs:

```tsx
// ✅ Advanced lazy loading with intelligence and control
import { useLazyLoading } from './hooks/useLazyLoading';

const Dashboard = () => {
  const { LazyComponent, preload, isLoading } = useLazyLoading({
    modules: {
      'admin': {
        loader: () => import('remote/AdminPanel'),
        priority: 'critical',           // Load first, always
        preloadTrigger: 'route-change',  // Start before user arrives
        bundleSize: 45000               // Track resource usage
      },
      'reports': {
        loader: () => import('remote/Reports'),
        priority: 'important',          // Load second priority
        preloadTrigger: 'intersection', // Load when scrolled into view
        bundleSize: 120000,
        requirements: { plan: 'premium' } // Only for eligible users
      },
      'analytics': {
        loader: () => import('remote/Analytics'),
        priority: 'background',         // Load during idle time
        preloadTrigger: 'idle',
        bundleSize: 200000,
        fallback: () => import('remote/BasicAnalytics') // Graceful degradation
      }
    }
  });

  return (
    <div>
      {/* Critical content loads immediately */}
      <LazyComponent name="admin" fallback={<AdminSkeleton />} />

      {/* Important content loads when needed */}
      <LazyComponent name="reports" fallback={<ReportsSkeleton />} />

      {/* Optional content loads in background */}
      <LazyComponent name="analytics" fallback={<AnalyticsSkeleton />} />
    </div>
  );
};
```

✅ **Immediate Validation** (Quick):
```bash
# 1. Performance Timeline - See actual prioritization
# DevTools → Performance → Record → Navigate → Stop
# ✅ Success: Critical components load first regardless of code order
# ✅ Success: Background loading doesn't block critical content

# 2. Bundle Analysis - Verify intelligent splitting
npx webpack-bundle-analyzer build/static/js/*.js
# ✅ Success: Logical chunk sizes (5-200KB), clear vendor separation
# ✅ Success: Context-specific bundles (admin vs user variants)

# 3. Network Simulation - Test different conditions
# DevTools → Network → Slow 3G
# ✅ Success: Essential features load first, optional features deferred
# ✅ Success: Graceful fallbacks prevent timeout errors
```

**Real-World Benefits You'll See**:
- 40-60% faster perceived loading time
- 30-50% reduction in initial bundle size
- Zero loading errors on slow networks
- Automatic optimization for different user contexts

---

## 🧠 Advanced Lazy Loading Concepts

**What**: Sophisticated patterns that go beyond React.lazy to optimize loading behavior at scale
**Why**: Basic lazy loading becomes insufficient as applications grow in complexity and size
**When**: Essential for production micro-frontends with multiple teams and complex user journeys

**Core Advanced Concepts**:
- **Priority-based loading**: Critical features load first, optional features load later
- **Intelligent preloading**: Predict what users need before they ask for it
- **Context-aware splitting**: Split code based on user behavior and capabilities
- **Resource budgeting**: Manage loading within performance constraints

## 📊 Advanced Loading Strategies

### 1. Priority-Based Lazy Loading

**Concept**: Load components based on their importance to user experience rather than order of appearance.

**What priority-based loading does**:
- Categorizes components by business importance (critical/important/optional)
- Loads high-priority components first, even if they appear later in the code
- Defers low-priority components until after critical content is ready
- Adapts loading strategy based on user context (role, plan, device)

**Why this matters**:
- **User Experience**: Critical features appear faster
- **Performance**: Optimal use of network bandwidth
- **Business Impact**: Important features get priority over nice-to-haves
- **Scalability**: Systematic approach works across large applications

```tsx
// hooks/usePriorityLoading.ts
import { useState, useEffect, useCallback } from 'react';

type LoadingPriority = 'critical' | 'important' | 'optional' | 'background';

interface LoadingConfig {
  priority: LoadingPriority;
  loader: () => Promise<any>;
  dependencies?: string[];
  conditions?: () => boolean;
}

export const usePriorityLoading = (configs: Record<string, LoadingConfig>) => {
  const [loadedModules, setLoadedModules] = useState<Record<string, any>>({});
  const [loadingStates, setLoadingStates] = useState<Record<string, boolean>>({});

  const loadByPriority = useCallback(async () => {
    // Sort by priority
    const priorityOrder: LoadingPriority[] = ['critical', 'important', 'optional', 'background'];

    for (const priority of priorityOrder) {
      const modulesToLoad = Object.entries(configs)
        .filter(([_, config]) => config.priority === priority)
        .filter(([_, config]) => !config.conditions || config.conditions());

      // Load all modules of the same priority in parallel
      await Promise.allSettled(
        modulesToLoad.map(async ([name, config]) => {
          // Check dependencies first
          if (config.dependencies) {
            const dependenciesReady = config.dependencies.every(dep => loadedModules[dep]);
            if (!dependenciesReady) return;
          }

          setLoadingStates(prev => ({ ...prev, [name]: true }));

          try {
            const module = await config.loader();
            setLoadedModules(prev => ({ ...prev, [name]: module }));
          } catch (error) {
            console.error(`Failed to load ${name}:`, error);
          } finally {
            setLoadingStates(prev => ({ ...prev, [name]: false }));
          }
        })
      );

      // Small delay between priority levels to prevent blocking
      if (priority === 'critical') {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
  }, [configs, loadedModules]);

  useEffect(() => {
    loadByPriority();
  }, [loadByPriority]);

  return { loadedModules, loadingStates };
};

// Usage example
const App = () => {
  const { loadedModules, loadingStates } = usePriorityLoading({
    header: {
      priority: 'critical',
      loader: () => import('remote/Header')
    },
    navigation: {
      priority: 'critical',
      loader: () => import('remote/Navigation'),
      dependencies: ['header']
    },
    dashboard: {
      priority: 'important',
      loader: () => import('remote/Dashboard'),
      dependencies: ['header', 'navigation']
    },
    reports: {
      priority: 'optional',
      loader: () => import('remote/Reports'),
      conditions: () => user.hasReportsAccess
    },
    analytics: {
      priority: 'background',
      loader: () => import('remote/Analytics')
    }
  });

  return (
    <div>
      {loadedModules.header && <loadedModules.header.default />}
      {loadedModules.navigation && <loadedModules.navigation.default />}
      {loadedModules.dashboard ? (
        <loadedModules.dashboard.default />
      ) : (
        loadingStates.dashboard && <DashboardSkeleton />
      )}
    </div>
  );
};
```

### 2. Intelligent Preloading Strategies

**Concept**: Predict and preload components based on user behavior patterns, not just proximity.

**Advanced preloading techniques**:
- **Behavioral prediction**: Learn from user patterns to predict next actions
- **Network-aware loading**: Adapt strategy based on connection quality
- **Resource scheduling**: Time preloading to avoid competing with critical resources
- **Cache optimization**: Intelligent cache warming and invalidation

```tsx
// hooks/useIntelligentPreloading.ts
import { useEffect, useRef, useCallback } from 'react';

interface PreloadConfig {
  trigger: 'hover' | 'intersection' | 'idle' | 'prediction' | 'scheduled';
  probability?: number; // For prediction-based loading
  delay?: number; // For scheduled loading
  networkThreshold?: 'slow' | 'fast' | 'any';
}

class IntelligentPreloader {
  private cache = new Map<string, Promise<any>>();
  private userBehavior = new Map<string, number>();
  private preloadHistory: string[] = [];

  // Learn from user behavior
  trackInteraction = (feature: string) => {
    const currentCount = this.userBehavior.get(feature) || 0;
    this.userBehavior.set(feature, currentCount + 1);
    this.preloadHistory.push(feature);

    // Keep only recent history
    if (this.preloadHistory.length > 50) {
      this.preloadHistory.shift();
    }
  };

  // Predict next likely interaction
  predictNext = (): string[] => {
    if (this.preloadHistory.length < 3) return [];

    const recent = this.preloadHistory.slice(-3);
    const patterns = new Map<string, number>();

    // Find common patterns after recent interactions
    for (let i = 0; i < this.preloadHistory.length - 3; i++) {
      const window = this.preloadHistory.slice(i, i + 3);
      if (JSON.stringify(window) === JSON.stringify(recent)) {
        const next = this.preloadHistory[i + 3];
        if (next) {
          patterns.set(next, (patterns.get(next) || 0) + 1);
        }
      }
    }

    // Return predictions sorted by likelihood
    return Array.from(patterns.entries())
      .sort(([,a], [,b]) => b - a)
      .slice(0, 2)
      .map(([feature]) => feature);
  };

  // Check network conditions
  getNetworkQuality = (): 'slow' | 'fast' => {
    if ('connection' in navigator) {
      const connection = (navigator as any).connection;
      const effectiveType = connection?.effectiveType;
      return ['slow-2g', '2g', '3g'].includes(effectiveType) ? 'slow' : 'fast';
    }
    return 'fast';
  };

  // Intelligent preloading with multiple strategies
  preload = async (
    moduleName: string,
    loader: () => Promise<any>,
    config: PreloadConfig
  ): Promise<any> => {
    // Check if already cached
    if (this.cache.has(moduleName)) {
      return this.cache.get(moduleName);
    }

    // Network quality check
    if (config.networkThreshold && config.networkThreshold !== 'any') {
      const networkQuality = this.getNetworkQuality();
      if (
        (config.networkThreshold === 'fast' && networkQuality === 'slow') ||
        (config.networkThreshold === 'slow' && networkQuality === 'fast')
      ) {
        return null; // Skip preloading
      }
    }

    // Probability check for prediction-based loading
    if (config.probability && Math.random() > config.probability) {
      return null;
    }

    // Schedule the preload
    const preloadPromise = this.schedulePreload(loader, config);
    this.cache.set(moduleName, preloadPromise);

    return preloadPromise;
  };

  private schedulePreload = async (
    loader: () => Promise<any>,
    config: PreloadConfig
  ): Promise<any> => {
    if (config.delay) {
      await new Promise(resolve => setTimeout(resolve, config.delay));
    }

    if (config.trigger === 'idle') {
      return new Promise(resolve => {
        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => resolve(loader()));
        } else {
          setTimeout(() => resolve(loader()), 1000);
        }
      });
    }

    return loader();
  };
}

export const intelligentPreloader = new IntelligentPreloader();

export const useIntelligentPreloading = () => {
  const currentRoute = useRef('');

  const preloadByStrategy = useCallback((
    moduleName: string,
    loader: () => Promise<any>,
    config: PreloadConfig
  ) => {
    switch (config.trigger) {
      case 'prediction':
        const predictions = intelligentPreloader.predictNext();
        if (predictions.includes(moduleName)) {
          intelligentPreloader.preload(moduleName, loader, {
            ...config,
            probability: 0.7
          });
        }
        break;

      case 'intersection':
        // Preload when element comes into view
        const observer = new IntersectionObserver((entries) => {
          if (entries[0].isIntersecting) {
            intelligentPreloader.preload(moduleName, loader, config);
            observer.disconnect();
          }
        });
        return observer;

      case 'scheduled':
        // Preload at specific times
        intelligentPreloader.preload(moduleName, loader, config);
        break;

      default:
        intelligentPreloader.preload(moduleName, loader, config);
    }
  }, []);

  const trackUserInteraction = useCallback((feature: string) => {
    intelligentPreloader.trackInteraction(feature);
  }, []);

  return { preloadByStrategy, trackUserInteraction };
};
```

### 3. Context-Aware Code Splitting

**Concept**: Split code based on user context (role, device, location) rather than just technical boundaries.

**Context-aware strategies**:
- **User role splitting**: Different bundles for admin vs regular users
- **Device capability splitting**: Heavy features only on capable devices
- **Geographic splitting**: Region-specific features and localizations
- **Plan-based splitting**: Premium features only for paid users

```tsx
// utils/contextAwareSplitting.ts
interface UserContext {
  role: 'admin' | 'user' | 'guest';
  device: 'mobile' | 'tablet' | 'desktop';
  plan: 'free' | 'premium' | 'enterprise';
  region: string;
  capabilities: {
    webgl: boolean;
    webworkers: boolean;
    serviceworker: boolean;
  };
}

class ContextAwareSplitter {
  private userContext: UserContext;

  constructor(userContext: UserContext) {
    this.userContext = userContext;
  }

  // Determine which bundle variant to load
  getContextualLoader = (
    baseName: string,
    variants: Record<string, () => Promise<any>>
  ) => {
    // Role-based splitting
    if (this.userContext.role === 'admin' && variants[`${baseName}-admin`]) {
      return variants[`${baseName}-admin`];
    }

    // Plan-based splitting
    if (this.userContext.plan === 'enterprise' && variants[`${baseName}-enterprise`]) {
      return variants[`${baseName}-enterprise`];
    }

    if (this.userContext.plan === 'premium' && variants[`${baseName}-premium`]) {
      return variants[`${baseName}-premium`];
    }

    // Device-based splitting
    if (this.userContext.device === 'mobile' && variants[`${baseName}-mobile`]) {
      return variants[`${baseName}-mobile`];
    }

    // Capability-based splitting
    if (!this.userContext.capabilities.webgl && variants[`${baseName}-fallback`]) {
      return variants[`${baseName}-fallback`];
    }

    // Default variant
    return variants[baseName] || variants.default;
  };

  // Load appropriate bundle based on context
  loadContextual = async (baseName: string, variants: Record<string, () => Promise<any>>) => {
    const loader = this.getContextualLoader(baseName, variants);

    if (!loader) {
      throw new Error(`No suitable variant found for ${baseName}`);
    }

    try {
      return await loader();
    } catch (error) {
      console.warn(`Failed to load ${baseName}, trying fallback...`);

      // Try fallback options
      const fallbackLoader = variants.default || variants[`${baseName}-fallback`];
      if (fallbackLoader) {
        return await fallbackLoader();
      }

      throw error;
    }
  };
}

// Usage example
const useContextualLoading = (userContext: UserContext) => {
  const splitter = new ContextAwareSplitter(userContext);

  const loadDashboard = useCallback(() => {
    return splitter.loadContextual('dashboard', {
      'dashboard-admin': () => import('remote/AdminDashboard'),
      'dashboard-enterprise': () => import('remote/EnterpriseDashboard'),
      'dashboard-premium': () => import('remote/PremiumDashboard'),
      'dashboard-mobile': () => import('remote/MobileDashboard'),
      'dashboard': () => import('remote/Dashboard'),
      'default': () => import('remote/BasicDashboard')
    });
  }, [splitter]);

  const loadAnalytics = useCallback(() => {
    return splitter.loadContextual('analytics', {
      'analytics-enterprise': () => import('remote/AdvancedAnalytics'),
      'analytics-premium': () => import('remote/PremiumAnalytics'),
      'analytics-fallback': () => import('remote/BasicAnalytics'),
      'analytics': () => import('remote/Analytics')
    });
  }, [splitter]);

  return { loadDashboard, loadAnalytics };
};
```

---

## 🎯 30-Second Quick Wins

### Priority-Based Loading (Quick)
```tsx
// Load components by importance, not order
const Header = lazy(() => import('remote/Header'));      // Load first
const Dashboard = lazy(() => import('remote/Dashboard')); // Load second
const Reports = lazy(() => import('remote/Reports'));     // Load last

// Usage with priority hints
<Suspense fallback={<HeaderSkeleton />}>
  <Header /> {/* Highest priority - loads immediately */}
</Suspense>

<Suspense fallback={<DashboardSkeleton />}>
  <Dashboard /> {/* Medium priority - loads after header */}
</Suspense>

// ✅ Result: Critical components load first regardless of code order
// ✅ Benefit: Better perceived performance, faster time to interactive
```

### Feature Flag Integration (Simple)
```tsx
// Only download enabled features - 2 lines
const AdvancedAnalytics = lazy(() =>
  featureFlags.advancedAnalytics
    ? import('remote/AdvancedAnalytics')
    : Promise.resolve({ default: () => null })
);

// ✅ Result: Disabled features consume zero bandwidth
// ✅ Benefit: Smaller bundles, instant A/B testing, gradual rollouts
```

### Viewport-Aware Loading (Simple)
```tsx
// Load when scrolled into view - copy this hook
const useViewportLoading = () => {
  const ref = useRef();
  const [inView, setInView] = useState(false);

  useEffect(() => {
    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        setInView(true);
        observer.disconnect();
      }
    });
    if (ref.current) observer.observe(ref.current);
    return () => observer.disconnect();
  }, []);

  return [ref, inView];
};

// Usage
const [ref, inView] = useViewportLoading();
return (
  <div ref={ref}>
    {inView ? <LazyComponent /> : <PlaceholderSkeleton />}
  </div>
);

// ✅ Result: Below-fold content loads only when needed
// ✅ Benefit: 40-60% faster initial page load
```

### Performance Budget Monitoring (Detailed)
```tsx
// Monitor bundle sizes in real-time - copy this utility
const useBundleMonitor = () => {
  const [bundles, setBundles] = useState([]);

  const trackBundle = useCallback((name, size) => {
    setBundles(prev => [...prev, { name, size, timestamp: Date.now() }]);

    // Alert if bundle is too large
    if (size > 200000) { // 200KB threshold
      console.warn(`⚠️ Large bundle detected: ${name} (${(size/1000).toFixed(1)}KB)`);
    }
  }, []);

  const getTotalSize = () => bundles.reduce((sum, b) => sum + b.size, 0);

  return { trackBundle, bundles, totalSize: getTotalSize() };
};

// Usage in lazy loading
const LazyComponent = lazy(async () => {
  const start = performance.now();
  const module = await import('remote/Component');
  const loadTime = performance.now() - start;

  trackBundle('Component', loadTime);
  return module;
});

// ✅ Result: Real-time visibility into loading performance
// ✅ Benefit: Data-driven optimization, early warning system
```

---

## ⚡ Advanced Production Strategies

### 1. Micro-Bundle Architecture

**Concept**: Break remote applications into tiny, highly-focused bundles that can be composed dynamically.

**What micro-bundle architecture does**:
- Splits remotes into feature-specific micro-bundles (5-20KB each)
- Enables granular loading based on user actions
- Allows mixing and matching features from different remotes
- Provides maximum flexibility for complex applications

```tsx
// micro-bundles/BundleOrchestrator.tsx
interface MicroBundle {
  id: string;
  size: number;
  dependencies: string[];
  loader: () => Promise<any>;
  priority: number;
  expiry: number; // Cache expiry time
}

class BundleOrchestrator {
  private bundles = new Map<string, MicroBundle>();
  private loadedBundles = new Map<string, any>();
  private loadingPromises = new Map<string, Promise<any>>();

  register = (bundle: MicroBundle) => {
    this.bundles.set(bundle.id, bundle);
  };

  // Load bundles in optimal order
  loadBundles = async (bundleIds: string[]): Promise<Record<string, any>> => {
    // Sort by priority and dependencies
    const sortedBundles = this.topologicalSort(bundleIds);
    const results: Record<string, any> = {};

    // Load in batches based on dependencies
    for (const batch of this.createBatches(sortedBundles)) {
      const batchPromises = batch.map(bundleId => this.loadBundle(bundleId));
      const batchResults = await Promise.allSettled(batchPromises);

      batchResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          results[batch[index]] = result.value;
        }
      });
    }

    return results;
  };

  private loadBundle = async (bundleId: string): Promise<any> => {
    // Check cache first
    if (this.loadedBundles.has(bundleId)) {
      const cached = this.loadedBundles.get(bundleId);
      if (Date.now() < cached.expiry) {
        return cached.module;
      }
    }

    // Check if already loading
    if (this.loadingPromises.has(bundleId)) {
      return this.loadingPromises.get(bundleId);
    }

    const bundle = this.bundles.get(bundleId);
    if (!bundle) {
      throw new Error(`Bundle ${bundleId} not found`);
    }

    // Start loading
    const loadingPromise = bundle.loader().then(module => {
      this.loadedBundles.set(bundleId, {
        module,
        expiry: Date.now() + bundle.expiry
      });
      this.loadingPromises.delete(bundleId);
      return module;
    });

    this.loadingPromises.set(bundleId, loadingPromise);
    return loadingPromise;
  };

  private topologicalSort = (bundleIds: string[]): string[] => {
    // Implementation of topological sort for dependency ordering
    const visited = new Set<string>();
    const result: string[] = [];

    const visit = (bundleId: string) => {
      if (visited.has(bundleId)) return;
      visited.add(bundleId);

      const bundle = this.bundles.get(bundleId);
      if (bundle) {
        bundle.dependencies.forEach(visit);
        result.push(bundleId);
      }
    };

    bundleIds.forEach(visit);
    return result;
  };

  private createBatches = (sortedBundles: string[]): string[][] => {
    const batches: string[][] = [];
    const dependencyMap = new Map<string, string[]>();

    // Build dependency map
    sortedBundles.forEach(bundleId => {
      const bundle = this.bundles.get(bundleId);
      if (bundle) {
        dependencyMap.set(bundleId, bundle.dependencies);
      }
    });

    // Create batches where all dependencies are in previous batches
    sortedBundles.forEach(bundleId => {
      const dependencies = dependencyMap.get(bundleId) || [];
      let batchIndex = 0;

      // Find the earliest batch where all dependencies are satisfied
      for (let i = 0; i < batches.length; i++) {
        const prevBundles = batches.slice(0, i + 1).flat();
        if (dependencies.every(dep => prevBundles.includes(dep))) {
          batchIndex = i + 1;
          break;
        }
      }

      if (!batches[batchIndex]) {
        batches[batchIndex] = [];
      }
      batches[batchIndex].push(bundleId);
    });

    return batches;
  };
}

export const bundleOrchestrator = new BundleOrchestrator();

// Register micro-bundles
bundleOrchestrator.register({
  id: 'user-profile',
  size: 15000,
  dependencies: [],
  loader: () => import('remote/UserProfile'),
  priority: 1,
  expiry: 300000 // 5 minutes
});

bundleOrchestrator.register({
  id: 'user-settings',
  size: 8000,
  dependencies: ['user-profile'],
  loader: () => import('remote/UserSettings'),
  priority: 2,
  expiry: 600000 // 10 minutes
});

// Usage
const UserSection = () => {
  const [bundles, setBundles] = useState<Record<string, any>>({});

  useEffect(() => {
    bundleOrchestrator.loadBundles(['user-profile', 'user-settings'])
      .then(setBundles);
  }, []);

  return (
    <div>
      {bundles['user-profile'] && <bundles['user-profile'].default />}
      {bundles['user-settings'] && <bundles['user-settings'].default />}
    </div>
  );
};
```

### 2. Performance Budget Management

**Concept**: Systematically manage loading performance within defined constraints.

```tsx
// utils/PerformanceBudget.tsx
interface BudgetConfig {
  initialLoad: number; // Max initial bundle size (bytes)
  routeLoad: number; // Max additional load per route (bytes)
  totalMemory: number; // Max total memory usage (bytes)
  loadTime: number; // Max acceptable load time (ms)
}

class PerformanceBudgetManager {
  private config: BudgetConfig;
  private currentUsage = {
    bundleSize: 0,
    memoryUsage: 0,
    loadTime: 0
  };

  constructor(config: BudgetConfig) {
    this.config = config;
  }

  // Check if loading a bundle would exceed budget
  canLoad = async (bundleName: string, estimatedSize: number): Promise<boolean> => {
    // Check bundle size budget
    if (this.currentUsage.bundleSize + estimatedSize > this.config.routeLoad) {
      console.warn(`Bundle ${bundleName} would exceed size budget`);
      return false;
    }

    // Check memory budget
    const estimatedMemory = estimatedSize * 2; // Rough estimate
    if (this.currentUsage.memoryUsage + estimatedMemory > this.config.totalMemory) {
      console.warn(`Bundle ${bundleName} would exceed memory budget`);

      // Try to free memory first
      await this.freeMemory();

      // Check again
      if (this.currentUsage.memoryUsage + estimatedMemory > this.config.totalMemory) {
        return false;
      }
    }

    return true;
  };

  // Load with budget monitoring
  loadWithBudget = async (
    bundleName: string,
    loader: () => Promise<any>,
    estimatedSize: number
  ): Promise<any> => {
    if (!(await this.canLoad(bundleName, estimatedSize))) {
      throw new Error(`Cannot load ${bundleName}: would exceed performance budget`);
    }

    const startTime = performance.now();
    const startMemory = this.getMemoryUsage();

    try {
      const module = await loader();

      const loadTime = performance.now() - startTime;
      const memoryIncrease = this.getMemoryUsage() - startMemory;

      // Update usage tracking
      this.currentUsage.bundleSize += estimatedSize;
      this.currentUsage.memoryUsage += memoryIncrease;
      this.currentUsage.loadTime = Math.max(this.currentUsage.loadTime, loadTime);

      // Check if load time exceeded budget
      if (loadTime > this.config.loadTime) {
        console.warn(`Bundle ${bundleName} exceeded load time budget: ${loadTime}ms`);
      }

      return module;
    } catch (error) {
      console.error(`Failed to load ${bundleName}:`, error);
      throw error;
    }
  };

  private getMemoryUsage = (): number => {
    if ('memory' in performance) {
      return (performance as any).memory.usedJSHeapSize;
    }
    return 0;
  };

  private freeMemory = async (): Promise<void> => {
    // Force garbage collection if available
    if ('gc' in window) {
      (window as any).gc();
    }

    // Clear unused caches
    if ('caches' in window) {
      const cacheNames = await caches.keys();
      const oldCaches = cacheNames.filter(name => name.includes('old-'));
      await Promise.all(oldCaches.map(name => caches.delete(name)));
    }

    // Update memory usage
    this.currentUsage.memoryUsage = this.getMemoryUsage();
  };

  getBudgetReport = () => ({
    config: this.config,
    usage: this.currentUsage,
    remaining: {
      bundleSize: this.config.routeLoad - this.currentUsage.bundleSize,
      memoryUsage: this.config.totalMemory - this.currentUsage.memoryUsage,
      loadTime: this.config.loadTime - this.currentUsage.loadTime
    }
  });
}

// Usage
const budgetManager = new PerformanceBudgetManager({
  initialLoad: 250000, // 250KB
  routeLoad: 500000,   // 500KB per route
  totalMemory: 50000000, // 50MB
  loadTime: 2000       // 2 seconds
});

const useBudgetedLoading = () => {
  const loadWithBudget = useCallback(async (
    bundleName: string,
    loader: () => Promise<any>,
    estimatedSize = 100000 // Default 100KB estimate
  ) => {
    return budgetManager.loadWithBudget(bundleName, loader, estimatedSize);
  }, []);

  return { loadWithBudget, getBudgetReport: budgetManager.getBudgetReport };
};
```

---

## 🧪 Complete Production Example

```tsx
// components/AdvancedLazyApp.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { usePriorityLoading } from '../hooks/usePriorityLoading';
import { useIntelligentPreloading } from '../hooks/useIntelligentPreloading';
import { bundleOrchestrator } from '../micro-bundles/BundleOrchestrator';
import { useBudgetedLoading } from '../utils/PerformanceBudget';

interface AppConfig {
  user: {
    role: 'admin' | 'user' | 'guest';
    plan: 'free' | 'premium' | 'enterprise';
    preferences: {
      theme: 'light' | 'dark';
      language: string;
    };
  };
  features: Record<string, boolean>;
  device: 'mobile' | 'tablet' | 'desktop';
}

const AdvancedLazyApp: React.FC<{ config: AppConfig }> = ({ config }) => {
  const [activeFeatures, setActiveFeatures] = useState<string[]>(['header', 'navigation']);
  const { loadWithBudget, getBudgetReport } = useBudgetedLoading();
  const { preloadByStrategy, trackUserInteraction } = useIntelligentPreloading();

  // Priority-based loading configuration
  const { loadedModules, loadingStates } = usePriorityLoading({
    header: {
      priority: 'critical',
      loader: () => loadWithBudget('header', () => import('remote/Header'), 25000)
    },
    navigation: {
      priority: 'critical',
      loader: () => loadWithBudget('navigation', () => import('remote/Navigation'), 30000),
      dependencies: ['header']
    },
    dashboard: {
      priority: 'important',
      loader: () => loadWithBudget('dashboard',
        () => config.user.role === 'admin'
          ? import('remote/AdminDashboard')
          : import('remote/UserDashboard'),
        100000
      ),
      conditions: () => activeFeatures.includes('dashboard')
    },
    reports: {
      priority: 'optional',
      loader: () => loadWithBudget('reports', () => import('remote/Reports'), 150000),
      conditions: () => config.features.reports && config.user.plan !== 'free'
    },
    analytics: {
      priority: 'background',
      loader: () => loadWithBudget('analytics', () => import('remote/Analytics'), 200000),
      conditions: () => config.features.analytics
    }
  });

  // Intelligent preloading setup
  useEffect(() => {
    // Set up predictive preloading
    preloadByStrategy('reports', () => import('remote/Reports'), {
      trigger: 'prediction',
      probability: 0.6,
      networkThreshold: 'fast'
    });

    preloadByStrategy('analytics', () => import('remote/Analytics'), {
      trigger: 'idle',
      delay: 3000,
      networkThreshold: 'any'
    });

    // Set up micro-bundles
    bundleOrchestrator.register({
      id: 'dashboard-widgets',
      size: 50000,
      dependencies: ['dashboard'],
      loader: () => import('remote/DashboardWidgets'),
      priority: 3,
      expiry: 600000
    });

    bundleOrchestrator.register({
      id: 'user-preferences',
      size: 20000,
      dependencies: [],
      loader: () => import('remote/UserPreferences'),
      priority: 2,
      expiry: 1800000 // 30 minutes
    });
  }, [preloadByStrategy]);

  // Handle user interactions for learning
  const handleFeatureActivation = useCallback((feature: string) => {
    trackUserInteraction(feature);

    if (!activeFeatures.includes(feature)) {
      setActiveFeatures(prev => [...prev, feature]);
    }
  }, [trackUserInteraction, activeFeatures]);

  // Performance monitoring
  useEffect(() => {
    const interval = setInterval(() => {
      const report = getBudgetReport();
      console.log('Performance Budget Report:', report);

      // Alert if approaching budget limits
      if (report.remaining.bundleSize < 50000) {
        console.warn('Approaching bundle size budget limit');
      }
    }, 30000); // Check every 30 seconds

    return () => clearInterval(interval);
  }, [getBudgetReport]);

  return (
    <div className="advanced-lazy-app">
      {/* Critical components - always loaded */}
      <div className="critical-section">
        {loadedModules.header && <loadedModules.header.default />}
        {loadedModules.navigation && (
          <loadedModules.navigation.default
            onFeatureSelect={handleFeatureActivation}
            activeFeatures={activeFeatures}
          />
        )}
      </div>

      {/* Main content area with intelligent loading */}
      <main className="content-area">
        {activeFeatures.includes('dashboard') && (
          <section className="dashboard-section">
            {loadedModules.dashboard ? (
              <loadedModules.dashboard.default />
            ) : loadingStates.dashboard ? (
              <DashboardSkeleton />
            ) : (
              <button onClick={() => handleFeatureActivation('dashboard')}>
                Load Dashboard
              </button>
            )}
          </section>
        )}

        {activeFeatures.includes('reports') && config.user.plan !== 'free' && (
          <section className="reports-section">
            {loadedModules.reports ? (
              <loadedModules.reports.default />
            ) : loadingStates.reports ? (
              <ReportsSkeleton />
            ) : (
              <div className="feature-placeholder">
                <h3>Advanced Reports</h3>
                <button onClick={() => handleFeatureActivation('reports')}>
                  Load Reports
                </button>
              </div>
            )}
          </section>
        )}

        {activeFeatures.includes('analytics') && (
          <section className="analytics-section">
            {loadedModules.analytics ? (
              <loadedModules.analytics.default />
            ) : loadingStates.analytics ? (
              <AnalyticsSkeleton />
            ) : (
              <div className="feature-placeholder">
                <h3>Analytics Dashboard</h3>
                <p>Loading in background...</p>
              </div>
            )}
          </section>
        )}
      </main>

      {/* Performance indicator */}
      <PerformanceBudgetIndicator
        report={getBudgetReport()}
        onBudgetExceeded={() => {
          console.warn('Performance budget exceeded, optimizing...');
          // Could trigger cleanup or alternative loading strategies
        }}
      />
    </div>
  );
};

// Supporting components
const DashboardSkeleton: React.FC = () => (
  <div className="skeleton dashboard-skeleton">
    <div className="skeleton-header" />
    <div className="skeleton-content">
      <div className="skeleton-card" />
      <div className="skeleton-card" />
      <div className="skeleton-card" />
    </div>
  </div>
);

const ReportsSkeleton: React.FC = () => (
  <div className="skeleton reports-skeleton">
    <div className="skeleton-header" />
    <div className="skeleton-table">
      {[...Array(5)].map((_, i) => (
        <div key={i} className="skeleton-row" />
      ))}
    </div>
  </div>
);

const AnalyticsSkeleton: React.FC = () => (
  <div className="skeleton analytics-skeleton">
    <div className="skeleton-chart" />
    <div className="skeleton-metrics">
      {[...Array(4)].map((_, i) => (
        <div key={i} className="skeleton-metric" />
      ))}
    </div>
  </div>
);

const PerformanceBudgetIndicator: React.FC<{
  report: any;
  onBudgetExceeded: () => void;
}> = ({ report, onBudgetExceeded }) => {
  const budgetUtilization = (report.usage.bundleSize / report.config.routeLoad) * 100;

  useEffect(() => {
    if (budgetUtilization > 90) {
      onBudgetExceeded();
    }
  }, [budgetUtilization, onBudgetExceeded]);

  return (
    <div className="performance-indicator">
      <div className="budget-bar">
        <div
          className={`budget-fill ${budgetUtilization > 80 ? 'warning' : ''}`}
          style={{ width: `${Math.min(budgetUtilization, 100)}%` }}
        />
      </div>
      <span className="budget-text">
        Bundle: {Math.round(budgetUtilization)}%
      </span>
    </div>
  );
};

export default AdvancedLazyApp;
```

---

## 🧪 Hands-On Exercise

**Challenge**: Implement advanced lazy loading with performance monitoring for your micro-frontend setup

### Step 1: Set Up Priority-Based Loading
```tsx
// Implement the usePriorityLoading hook from the examples above
// Categorize your components by priority:
// - Critical: Always needed (header, navigation)
// - Important: Core features (dashboard, main content)
// - Optional: Secondary features (reports, settings)
// - Background: Nice-to-have (analytics, recommendations)
```

### Step 2: Add Performance Budget
```tsx
// Set up performance budget monitoring
const budgetConfig = {
  initialLoad: 200000,  // 200KB initial
  routeLoad: 400000,    // 400KB per route
  totalMemory: 30000000, // 30MB total
  loadTime: 1500        // 1.5s max load time
};

// Wrap all your imports with budget checking
const BudgetedComponent = lazy(() =>
  budgetManager.loadWithBudget('component', () => import('remote/Component'), 50000)
);
```

### Step 3: Implement Intelligent Preloading
```tsx
// Add hover preloading for likely next features
<button
  onMouseEnter={() => import('remote/NextFeature')}
  onClick={() => setShowFeature(true)}
>
  Next Feature
</button>

// Add intersection observer loading for below-fold content
const LazySection = lazy(() => import('remote/BelowFoldSection'));

// Use viewport loading hook from examples
```

### Step 4: Monitor and Optimize
```bash
# Build and analyze
npm run build
npx webpack-bundle-analyzer build/static/js/*.js

# Check performance
lighthouse http://localhost:3000 --only-categories=performance

# Monitor in browser
# DevTools → Performance → Record → Analyze loading patterns
# Look for: Logical loading order, no waterfalls, budget compliance

# Memory monitoring
# DevTools → Memory → Take heap snapshots
# Check for: Memory leaks, excessive memory usage
```

✅ **Success Criteria**:
- Components load in priority order (critical → important → optional)
- Performance budgets are respected (no budget exceeded warnings)
- Preloading improves perceived performance
- Memory usage stays within bounds
- Loading patterns adapt to user behavior

### Advanced Validation
```bash
# Test different scenarios
# 1. Slow network (Slow 3G) - should prioritize critical components
# 2. Fast network (WiFi) - should preload aggressively
# 3. Low memory device - should respect memory constraints
# 4. Different user roles - should load appropriate features

# Performance metrics to track:
# - First Contentful Paint (FCP) < 1.8s
# - Largest Contentful Paint (LCP) < 2.5s
# - Time to Interactive (TTI) < 3.5s
# - Total bundle size reduction > 40%
```

---

## ⚠️ Critical Pitfalls & Prevention

### Pitfall #1: "Chunk Storm" Killing Performance

**Symptoms**: App loads hundreds of tiny chunks, HTTP/2 multiplexing saturated
**Root Cause**: Micro-splitting without strategy - every component becomes a separate chunk

**Prevention Strategy**:
```tsx
// ❌ DANGER: Each import creates a new chunk (200+ requests)
const Button = lazy(() => import('remote/Button'));      // 2KB
const Icon = lazy(() => import('remote/Icon'));          // 1KB
const Modal = lazy(() => import('remote/Modal'));        // 3KB
const Tooltip = lazy(() => import('remote/Tooltip'));   // 2KB
// Result: Network saturation, worse performance than no splitting

// ✅ SOLUTION: Strategic bundling by usage patterns
const CoreUI = lazy(() => import('remote/CoreUIBundle'));     // 25KB - frequently used together
const AdminTools = lazy(() => import('remote/AdminBundle')); // 45KB - admin-only features
const Reports = lazy(() => import('remote/ReportsBundle'));  // 80KB - feature-complete bundle

// Webpack optimization to prevent micro-chunks
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      minSize: 20000,      // Block chunks smaller than 20KB
      maxSize: 200000,     // Split chunks larger than 200KB
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
          minSize: 100000    // Vendor bundles must be substantial
        }
      }
    }
  }
};
```

**Validation**: Check Network tab - should see <50 JS requests, not 200+

### Pitfall #2: Memory Hemorrhaging from Uncontrolled Preloading

**Symptoms**: Memory usage keeps climbing, eventual browser crashes on mobile
**Root Cause**: Aggressive preloading without lifecycle management

**Prevention Strategy**:
```tsx
// ❌ DANGER: Infinite memory growth pattern
const preloadEverything = () => {
  import('remote/Feature1');  // 50MB loaded
  import('remote/Feature2');  // +80MB
  import('remote/Feature3');  // +120MB
  // Mobile browsers crash around 200-300MB
};

// ✅ SOLUTION: LRU cache with memory bounds
class SmartPreloadCache {
  private cache = new Map();
  private maxItems = 8;        // Limit cached modules
  private maxMemory = 100000000; // 100MB memory budget

  preload = async (key: string, loader: () => Promise<any>, estimatedSize = 50000) => {
    // Check memory budget before loading
    if (this.getMemoryUsage() + estimatedSize > this.maxMemory) {
      this.evictOldest();
    }

    if (this.cache.has(key)) {
      // Move to end (most recently used)
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }

    // Ensure cache size limit
    if (this.cache.size >= this.maxItems) {
      this.evictOldest();
    }

    const module = await loader();
    this.cache.set(key, { module, size: estimatedSize, timestamp: Date.now() });
    return module;
  };

  private evictOldest = () => {
    const firstKey = this.cache.keys().next().value;
    this.cache.delete(firstKey);
    // Force garbage collection hint
    if ('gc' in window) (window as any).gc();
  };

  private getMemoryUsage = () => {
    return 'memory' in performance
      ? (performance as any).memory.usedJSHeapSize
      : this.cache.size * 25000; // Fallback estimate
  };
}
```

**Validation**: Monitor DevTools → Memory tab - usage should plateau, not climb infinitely

### Pitfall #3: Silent Bundle Size Explosion

**Symptoms**: Bundles grow 300-500% over months, no one notices until users complain
**Root Cause**: No systematic monitoring - "bundle bloat creep" goes undetected

**Prevention Strategy**:
```tsx
// ✅ SOLUTION: Automated bundle budget enforcement in CI/CD
// package.json
{
  "scripts": {
    "build:analyze": "yarn build && npx webpack-bundle-analyzer build/static/js/*.js --mode=json > bundle-report.json",
    "test:bundle-size": "node scripts/check-bundle-size.js",
    "validate:performance": "yarn test:bundle-size && lighthouse-ci"
  }
}

// scripts/check-bundle-size.js - FAIL CI if bundles exceed limits
const fs = require('fs');

const STRICT_LIMITS = {
  'main': 250000,       // 250KB initial bundle
  'vendor': 500000,     // 500KB vendor bundle
  'chunk': 150000,      // 150KB per route chunk
  'remote': 200000      // 200KB per remote
};

const report = JSON.parse(fs.readFileSync('bundle-report.json'));
let failed = false;

report.assets.forEach(asset => {
  const type = asset.name.includes('vendor') ? 'vendor' :
               asset.name.includes('main') ? 'main' :
               asset.name.includes('remote') ? 'remote' : 'chunk';

  if (asset.size > STRICT_LIMITS[type]) {
    console.error(`🚨 BUNDLE SIZE VIOLATION: ${asset.name}`);
    console.error(`   Size: ${(asset.size/1000).toFixed(1)}KB`);
    console.error(`   Limit: ${(STRICT_LIMITS[type]/1000).toFixed(1)}KB`);
    console.error(`   Overage: ${((asset.size - STRICT_LIMITS[type])/1000).toFixed(1)}KB`);
    failed = true;
  } else {
    console.log(`✅ ${asset.name}: ${(asset.size/1000).toFixed(1)}KB (within ${(STRICT_LIMITS[type]/1000).toFixed(1)}KB limit)`);
  }
});

if (failed) {
  console.error('\n💥 BUILD FAILED: Bundle size limits exceeded');
  console.error('🔧 Fix: Optimize imports, remove unused code, or split large chunks');
  process.exit(1);
}

console.log('\n🎉 All bundles within performance budget!');
```

**Validation**: CI/CD should block deployments when bundles exceed limits

### Pitfall #4: Cumulative Layout Shift (CLS) from Poor Loading UX

**Symptoms**: Content jumps around as components load, terrible user experience
**Root Cause**: Loading skeletons don't match actual component dimensions

**Prevention Strategy**:
```tsx
// ❌ DANGER: Unknown dimensions cause layout chaos
<Suspense fallback={<div>Loading...</div>}>
  <VariableHeightComponent /> {/* Could be 100px or 800px tall */}
</Suspense>
// Result: Content below jumps up/down as component loads

// ✅ SOLUTION: Precise skeleton matching actual component layout
const DashboardSkeleton = () => (
  <div className="dashboard-skeleton" style={{
    height: '600px',    // Exact height of loaded component
    width: '100%',
    display: 'grid',
    gridTemplateRows: '80px 400px 120px' // Match actual layout
  }}>
    <div className="skeleton-header shimmer" />
    <div className="skeleton-main shimmer" />
    <div className="skeleton-footer shimmer" />
  </div>
);

// Skeleton matches exactly what loads
<Suspense fallback={<DashboardSkeleton />}>
  <DashboardComponent /> {/* Same 600px height, same grid layout */}
</Suspense>

// CSS for better skeleton animations
.shimmer {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}
```

**Validation**: Core Web Vitals - CLS should be <0.1

---

## ✅ Best Practices Checklist

- [ ] **Priority-Based Loading**: Critical components load first
- [ ] **Performance Budgets**: Systematic monitoring of resource usage
- [ ] **Intelligent Preloading**: Predict user needs based on behavior
- [ ] **Context-Aware Splitting**: Adapt bundles to user context
- [ ] **Memory Management**: LRU caches and cleanup strategies
- [ ] **Bundle Size Monitoring**: CI/CD integration for size regression detection
- [ ] **Loading State Consistency**: Prevent layout shift with proper skeletons
- [ ] **Network Adaptation**: Different strategies for different connection types

---

## 🔍 Key Concepts Summary

| Concept | Definition | Example |
|---------|------------|---------|
| **Priority Loading** | Load components based on business importance | Critical → Important → Optional → Background |
| **Intelligent Preloading** | Predict and preload based on user behavior | Hover intent, intersection observer, idle time |
| **Context-Aware Splitting** | Different bundles for different user contexts | Admin vs user, mobile vs desktop, free vs premium |
| **Performance Budget** | Systematic resource management | 250KB initial, 500KB per route, 2s load time |
| **Micro-Bundle Architecture** | Fine-grained, composable bundle strategy | 5-20KB focused bundles with dependencies |

---

## 📖 Learning Path & Next Steps

### ✅ **Mastery Checklist - You Can Now:**

- [ ] Implement priority-based loading for optimal user experience
- [ ] Set up performance budgets and monitoring systems
- [ ] Use intelligent preloading to predict user needs
- [ ] Create context-aware code splitting strategies
- [ ] Design micro-bundle architectures for maximum flexibility
- [ ] Monitor and optimize bundle performance systematically
- [ ] Handle complex loading scenarios with graceful fallbacks

### 🎉 **Phase 2 Complete!**

You've mastered **Integration Mechanics**:
- ✅ 2.6: Component sharing and mounting fundamentals
- ✅ 2.7: Advanced loading patterns and error handling
- ✅ 2.8: Complete application mounting and orchestration
- ✅ 2.9: Strategic import optimization for performance
- ✅ 2.10: Advanced lazy loading and production optimization

### 🔜 **Next Phase**: [Phase 3: Styling and Isolation](../phase-3/)

**What you'll learn**: CSS isolation, design system sharing, and styling strategies for micro-frontends

### 🔮 **Your Learning Journey**:

```
Phase 1: Fundamentals → Phase 2: Integration (✅ Complete) → Phase 3: Styling → Phase 4: Shared Logic
```

---

## 🚀 Quick Reference Card

### Priority Loading
```tsx
const { loadedModules } = usePriorityLoading({
  critical: { priority: 'critical', loader: () => import('remote/Header') },
  important: { priority: 'important', loader: () => import('remote/Dashboard') },
  optional: { priority: 'optional', loader: () => import('remote/Reports') }
});
```

### Performance Budget
```tsx
const budgetManager = new PerformanceBudgetManager({
  initialLoad: 250000,
  routeLoad: 500000,
  totalMemory: 50000000,
  loadTime: 2000
});

const Component = lazy(() =>
  budgetManager.loadWithBudget('component', () => import('remote/Component'), 50000)
);
```

### Intelligent Preloading
```tsx
// Hover preloading
<button onMouseEnter={() => import('remote/Feature')}>

// Intersection preloading
const observer = new IntersectionObserver(([entry]) => {
  if (entry.isIntersecting) import('remote/BelowFold');
});

// Idle preloading
requestIdleCallback(() => import('remote/Background'));
```

---

## 📚 References

- [Code Splitting Best Practices](https://webpack.js.org/guides/code-splitting/)
- [Performance Budgets](https://web.dev/performance-budgets-101/)
- [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)
- [Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)