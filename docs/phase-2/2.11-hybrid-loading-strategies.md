# 2.11 Hybrid Loading Strategies: Combining Patterns for Production

> **What you'll learn**: How to combine registry patterns, lazy loading, dynamic imports, and mounting strategies for optimal micro-frontend performance
> 📊 **Difficulty**: Expert | 🛠️ **Prerequisites**: 2.6-2.10 (All Integration Mechanics)

## 🎯 The Missing Piece: Why Single Strategies Fall Short

### The Production Reality

**The Problem**: Real applications need multiple loading strategies working together, not isolated patterns.

```tsx
// ❌ Single strategy limitations in production
// Registry only: No lazy loading optimization
const registry = {
  'admin-panel': 'http://localhost:3001/remoteEntry.js',
  'reports': 'http://localhost:3002/remoteEntry.js'
};

// Lazy loading only: No dynamic registry updates
const AdminPanel = lazy(() => import('remote/AdminPanel'));

// Dynamic imports only: No mounting coordination
const loadReport = () => import('remote/Reports');

// Result: Sub-optimal performance, missing production features
```

### ✅ Production Solution: Hybrid Strategy Architecture

**The Strategy**: Combine patterns based on specific use cases and runtime conditions.

```tsx
// ✅ Hybrid approach: Registry + Lazy + Dynamic + Smart mounting
interface HybridLoadingStrategy {
  registry: DynamicRegistry;           // Runtime remote discovery
  lazyLoading: PriorityLazyLoader;     // Component-level optimization
  dynamicImports: ConditionalImporter; // Feature flag integration
  mounting: OrchestrationEngine;       // Lifecycle coordination
}

const ProductionApp = () => {
  const hybridLoader = useHybridLoading({
    // Registry for runtime remote discovery
    registryConfig: {
      discoveryUrl: '/api/remotes',
      fallbackRegistry: DEFAULT_REMOTES,
      updateInterval: 30000
    },

    // Priority-based lazy loading within remotes
    lazyConfig: {
      critical: ['header', 'navigation'],
      important: ['dashboard', 'user-profile'],
      optional: ['reports', 'analytics'],
      background: ['recommendations', 'audit-logs']
    },

    // Dynamic imports with conditions
    conditionalConfig: {
      features: featureFlags,
      userPlan: user.plan,
      deviceCapabilities: device.capabilities
    },

    // Coordinated mounting strategies
    mountingConfig: {
      mode: 'orchestrated',
      dependencies: APP_DEPENDENCIES,
      stateSync: globalStateManager
    }
  });

  return <hybridLoader.RenderApp />;
};
```

---

## 🔗 Strategy Combination Matrix

### When to Combine Which Patterns

| Use Case | Registry | Lazy Loading | Dynamic Imports | Mounting | Benefit |
|----------|----------|--------------|----------------|----------|---------|
| **Multi-tenant SaaS** | ✅ Dynamic | ✅ Priority-based | ✅ Plan-based | ✅ State sync | Different features per tenant |
| **Enterprise Portal** | ✅ Service discovery | ✅ Role-based | ✅ Permission-based | ✅ SSO coordination | Secure, scalable access |
| **E-commerce Platform** | ✅ A/B testing | ✅ Viewport-based | ✅ Cart-conditional | ✅ Payment coordination | Optimized conversion |
| **Mobile-first App** | ✅ CDN-based | ✅ Network-aware | ✅ Device-conditional | ✅ Memory-efficient | Performance on constraints |

---

## 📊 Core Hybrid Patterns

### 1. Registry + Priority Lazy Loading

**Concept**: Use registry to discover available remotes, then apply intelligent lazy loading within each remote.

**What this combination achieves**:
- Dynamic remote discovery for flexibility
- Optimized loading order within known remotes
- Graceful fallbacks when remotes are unavailable
- Runtime adaptation to changing remote availability

```tsx
// hooks/useRegistryLazyLoading.ts
import { useState, useEffect, useCallback } from 'react';

interface RemoteConfig {
  url: string;
  priority: 'critical' | 'important' | 'optional';
  modules: Record<string, {
    path: string;
    priority: 'critical' | 'important' | 'optional';
    preloadTrigger?: 'route' | 'intersection' | 'idle';
  }>;
  fallback?: string;
}

interface RegistryLazyConfig {
  registryUrl: string;
  fallbackRegistry: Record<string, RemoteConfig>;
  lazyLoadingStrategy: 'priority' | 'network-aware' | 'viewport-based';
}

export const useRegistryLazyLoading = (config: RegistryLazyConfig) => {
  const [remoteRegistry, setRemoteRegistry] = useState<Record<string, RemoteConfig>>(
    config.fallbackRegistry
  );
  const [loadedModules, setLoadedModules] = useState<Record<string, any>>({});
  const [loadingStates, setLoadingStates] = useState<Record<string, boolean>>({});

  // Dynamic registry updates
  const updateRegistry = useCallback(async () => {
    try {
      const response = await fetch(config.registryUrl);
      const dynamicRegistry = await response.json();

      // Merge with fallback registry
      setRemoteRegistry(prev => ({
        ...prev,
        ...dynamicRegistry.remotes
      }));
    } catch (error) {
      console.warn('Registry update failed, using fallback', error);
    }
  }, [config.registryUrl]);

  // Smart module loading based on priority and registry
  const loadModule = useCallback(async (
    remoteName: string,
    moduleName: string,
    overridePriority?: 'critical' | 'important' | 'optional'
  ) => {
    const remote = remoteRegistry[remoteName];
    if (!remote) {
      throw new Error(`Remote ${remoteName} not found in registry`);
    }

    const module = remote.modules[moduleName];
    if (!module) {
      throw new Error(`Module ${moduleName} not found in remote ${remoteName}`);
    }

    const moduleKey = `${remoteName}.${moduleName}`;

    // Check if already loading
    if (loadingStates[moduleKey]) {
      return;
    }

    setLoadingStates(prev => ({ ...prev, [moduleKey]: true }));

    try {
      // Priority-based loading with registry coordination
      const priority = overridePriority || module.priority;

      if (priority === 'critical') {
        // Load immediately
        const loadedModule = await import(/* webpackIgnore: true */ `${remote.url}/${module.path}`);
        setLoadedModules(prev => ({ ...prev, [moduleKey]: loadedModule }));
      } else if (priority === 'important') {
        // Load with small delay to not block critical
        setTimeout(async () => {
          try {
            const loadedModule = await import(/* webpackIgnore: true */ `${remote.url}/${module.path}`);
            setLoadedModules(prev => ({ ...prev, [moduleKey]: loadedModule }));
          } catch (error) {
            console.error(`Failed to load important module ${moduleKey}:`, error);
            // Try fallback if available
            if (remote.fallback) {
              const fallbackModule = await import(/* webpackIgnore: true */ remote.fallback);
              setLoadedModules(prev => ({ ...prev, [moduleKey]: fallbackModule }));
            }
          }
        }, 100);
      } else {
        // Load during idle time
        if ('requestIdleCallback' in window) {
          requestIdleCallback(async () => {
            try {
              const loadedModule = await import(/* webpackIgnore: true */ `${remote.url}/${module.path}`);
              setLoadedModules(prev => ({ ...prev, [moduleKey]: loadedModule }));
            } catch (error) {
              console.warn(`Optional module ${moduleKey} failed to load:`, error);
            }
          });
        }
      }
    } catch (error) {
      console.error(`Failed to load module ${moduleKey}:`, error);

      // Try fallback remote if available
      if (remote.fallback) {
        try {
          const fallbackModule = await import(/* webpackIgnore: true */ remote.fallback);
          setLoadedModules(prev => ({ ...prev, [moduleKey]: fallbackModule }));
        } catch (fallbackError) {
          console.error(`Fallback also failed for ${moduleKey}:`, fallbackError);
        }
      }
    } finally {
      setLoadingStates(prev => ({ ...prev, [moduleKey]: false }));
    }
  }, [remoteRegistry]);

  // Auto-load critical modules when registry updates
  useEffect(() => {
    Object.entries(remoteRegistry).forEach(([remoteName, remote]) => {
      Object.entries(remote.modules).forEach(([moduleName, module]) => {
        if (module.priority === 'critical') {
          loadModule(remoteName, moduleName);
        }
      });
    });
  }, [remoteRegistry, loadModule]);

  // Update registry on mount and interval
  useEffect(() => {
    updateRegistry();
    const interval = setInterval(updateRegistry, 60000); // Update every minute
    return () => clearInterval(interval);
  }, [updateRegistry]);

  return {
    remoteRegistry,
    loadedModules,
    loadingStates,
    loadModule,
    updateRegistry
  };
};

// Usage example
const HybridApp: React.FC = () => {
  const {
    remoteRegistry,
    loadedModules,
    loadingStates,
    loadModule
  } = useRegistryLazyLoading({
    registryUrl: '/api/micro-frontend-registry',
    fallbackRegistry: {
      'admin-panel': {
        url: 'http://localhost:3001',
        priority: 'important',
        modules: {
          'Dashboard': {
            path: '/modules/Dashboard',
            priority: 'critical'
          },
          'UserManagement': {
            path: '/modules/UserManagement',
            priority: 'important',
            preloadTrigger: 'route'
          },
          'AuditLogs': {
            path: '/modules/AuditLogs',
            priority: 'optional',
            preloadTrigger: 'idle'
          }
        },
        fallback: 'http://fallback-cdn.com/admin-panel'
      }
    },
    lazyLoadingStrategy: 'priority'
  });

  return (
    <div>
      {/* Critical modules load automatically */}
      {loadedModules['admin-panel.Dashboard'] && (
        <loadedModules['admin-panel.Dashboard'].default />
      )}

      {/* Important modules load on demand */}
      <button
        onClick={() => loadModule('admin-panel', 'UserManagement')}
        disabled={loadingStates['admin-panel.UserManagement']}
      >
        {loadingStates['admin-panel.UserManagement'] ? 'Loading...' : 'Load User Management'}
      </button>

      {/* Optional modules load automatically in background */}
      {loadedModules['admin-panel.AuditLogs'] && (
        <loadedModules['admin-panel.AuditLogs'].default />
      )}
    </div>
  );
};
```

### 2. Dynamic Imports + Conditional Mounting

**Concept**: Use dynamic imports with runtime conditions, then coordinate mounting based on application state.

**What this combination achieves**:
- Load only relevant features for current user context
- Coordinate complex mounting sequences between remotes
- Handle feature flags and A/B testing seamlessly
- Maintain consistent application state across remotes

```tsx
// utils/ConditionalMountingOrchestrator.ts
interface MountingCondition {
  featureFlag?: string;
  userRole?: string[];
  userPlan?: string[];
  deviceType?: 'mobile' | 'tablet' | 'desktop';
  networkSpeed?: 'slow' | 'fast';
  customCondition?: () => boolean;
}

interface ConditionalModule {
  import: () => Promise<any>;
  conditions: MountingCondition;
  dependencies?: string[];
  mountStrategy: 'immediate' | 'lazy' | 'onDemand';
  unmountStrategy: 'keepAlive' | 'destroy' | 'cache';
  stateRequirements?: string[];
}

class ConditionalMountingOrchestrator {
  private mountedModules = new Map<string, any>();
  private moduleStates = new Map<string, 'loading' | 'mounted' | 'error' | 'unmounted'>();
  private stateManager: any;
  private featureFlags: Record<string, boolean>;
  private userContext: any;

  constructor(stateManager: any, featureFlags: Record<string, boolean>, userContext: any) {
    this.stateManager = stateManager;
    this.featureFlags = featureFlags;
    this.userContext = userContext;
  }

  // Evaluate if module should be loaded based on conditions
  private shouldLoadModule = (conditions: MountingCondition): boolean => {
    // Feature flag check
    if (conditions.featureFlag && !this.featureFlags[conditions.featureFlag]) {
      return false;
    }

    // User role check
    if (conditions.userRole && !conditions.userRole.includes(this.userContext.role)) {
      return false;
    }

    // User plan check
    if (conditions.userPlan && !conditions.userPlan.includes(this.userContext.plan)) {
      return false;
    }

    // Device type check
    if (conditions.deviceType && conditions.deviceType !== this.userContext.device) {
      return false;
    }

    // Network speed check
    if (conditions.networkSpeed) {
      const connection = (navigator as any).connection;
      const isSlowNetwork = connection?.effectiveType === '2g' || connection?.effectiveType === 'slow-2g';

      if (conditions.networkSpeed === 'fast' && isSlowNetwork) {
        return false;
      }
      if (conditions.networkSpeed === 'slow' && !isSlowNetwork) {
        return false;
      }
    }

    // Custom condition check
    if (conditions.customCondition && !conditions.customCondition()) {
      return false;
    }

    return true;
  };

  // Load and mount module with coordination
  loadAndMount = async (
    moduleId: string,
    moduleConfig: ConditionalModule
  ): Promise<any> => {
    // Check conditions first
    if (!this.shouldLoadModule(moduleConfig.conditions)) {
      console.log(`Module ${moduleId} conditions not met, skipping`);
      return null;
    }

    // Check if already mounted
    if (this.mountedModules.has(moduleId)) {
      return this.mountedModules.get(moduleId);
    }

    // Check dependencies
    if (moduleConfig.dependencies) {
      const dependenciesReady = moduleConfig.dependencies.every(dep =>
        this.moduleStates.get(dep) === 'mounted'
      );

      if (!dependenciesReady) {
        throw new Error(`Dependencies not ready for ${moduleId}`);
      }
    }

    // Check state requirements
    if (moduleConfig.stateRequirements) {
      const stateReady = moduleConfig.stateRequirements.every(stateKey =>
        this.stateManager.hasState(stateKey)
      );

      if (!stateReady) {
        // Wait for required state
        await this.stateManager.waitForState(moduleConfig.stateRequirements);
      }
    }

    this.moduleStates.set(moduleId, 'loading');

    try {
      // Dynamic import with conditional logic
      const module = await moduleConfig.import();

      // Mount based on strategy
      let mountedInstance;
      switch (moduleConfig.mountStrategy) {
        case 'immediate':
          mountedInstance = await this.mountImmediate(moduleId, module);
          break;
        case 'lazy':
          mountedInstance = await this.mountLazy(moduleId, module);
          break;
        case 'onDemand':
          mountedInstance = this.prepareMountOnDemand(moduleId, module);
          break;
        default:
          mountedInstance = await this.mountImmediate(moduleId, module);
      }

      this.mountedModules.set(moduleId, mountedInstance);
      this.moduleStates.set(moduleId, 'mounted');

      return mountedInstance;

    } catch (error) {
      this.moduleStates.set(moduleId, 'error');
      console.error(`Failed to load and mount ${moduleId}:`, error);
      throw error;
    }
  };

  private mountImmediate = async (moduleId: string, module: any) => {
    // Mount immediately with state coordination
    const container = document.createElement('div');
    container.id = `micro-frontend-${moduleId}`;

    if (module.mount) {
      return await module.mount(container, {
        stateManager: this.stateManager,
        userContext: this.userContext,
        moduleId
      });
    }

    return module;
  };

  private mountLazy = async (moduleId: string, module: any) => {
    // Mount when actually needed
    return {
      mount: async (container: HTMLElement) => {
        if (module.mount) {
          return await module.mount(container, {
            stateManager: this.stateManager,
            userContext: this.userContext,
            moduleId
          });
        }
        return module;
      }
    };
  };

  private prepareMountOnDemand = (moduleId: string, module: any) => {
    // Return mounting function for on-demand use
    return {
      mount: async (container: HTMLElement, props?: any) => {
        if (module.mount) {
          return await module.mount(container, {
            stateManager: this.stateManager,
            userContext: this.userContext,
            moduleId,
            ...props
          });
        }
        return module;
      }
    };
  };

  // Unmount module based on strategy
  unmount = async (moduleId: string, strategy?: 'keepAlive' | 'destroy' | 'cache') => {
    const mountedModule = this.mountedModules.get(moduleId);
    if (!mountedModule) return;

    switch (strategy || 'destroy') {
      case 'keepAlive':
        // Keep in memory but hide
        if (mountedModule.hide) {
          await mountedModule.hide();
        }
        break;

      case 'cache':
        // Save state and unmount
        if (mountedModule.saveState) {
          await mountedModule.saveState();
        }
        if (mountedModule.unmount) {
          await mountedModule.unmount();
        }
        this.moduleStates.set(moduleId, 'unmounted');
        break;

      case 'destroy':
      default:
        // Fully unmount and cleanup
        if (mountedModule.unmount) {
          await mountedModule.unmount();
        }
        this.mountedModules.delete(moduleId);
        this.moduleStates.set(moduleId, 'unmounted');
        break;
    }
  };

  // Get current state of all modules
  getModuleStates = () => {
    return Object.fromEntries(this.moduleStates.entries());
  };
}

// Usage hook
export const useConditionalMounting = (
  modules: Record<string, ConditionalModule>,
  stateManager: any,
  featureFlags: Record<string, boolean>,
  userContext: any
) => {
  const [orchestrator] = useState(() =>
    new ConditionalMountingOrchestrator(stateManager, featureFlags, userContext)
  );
  const [moduleStates, setModuleStates] = useState<Record<string, string>>({});

  const loadModule = useCallback(async (moduleId: string) => {
    const moduleConfig = modules[moduleId];
    if (!moduleConfig) {
      throw new Error(`Module ${moduleId} not found`);
    }

    try {
      const result = await orchestrator.loadAndMount(moduleId, moduleConfig);
      setModuleStates(orchestrator.getModuleStates());
      return result;
    } catch (error) {
      setModuleStates(orchestrator.getModuleStates());
      throw error;
    }
  }, [modules, orchestrator]);

  const unmountModule = useCallback(async (
    moduleId: string,
    strategy?: 'keepAlive' | 'destroy' | 'cache'
  ) => {
    await orchestrator.unmount(moduleId, strategy);
    setModuleStates(orchestrator.getModuleStates());
  }, [orchestrator]);

  // Auto-load modules based on conditions
  useEffect(() => {
    Object.entries(modules).forEach(([moduleId, config]) => {
      if (config.mountStrategy === 'immediate') {
        loadModule(moduleId).catch(console.error);
      }
    });
  }, [modules, loadModule]);

  return {
    loadModule,
    unmountModule,
    moduleStates
  };
};

// Usage example
const ConditionalApp: React.FC = () => {
  const { loadModule, unmountModule, moduleStates } = useConditionalMounting(
    {
      'premium-dashboard': {
        import: () => import('remote/PremiumDashboard'),
        conditions: {
          featureFlag: 'premium-features',
          userPlan: ['premium', 'enterprise'],
          networkSpeed: 'fast'
        },
        dependencies: ['user-session'],
        mountStrategy: 'immediate',
        unmountStrategy: 'keepAlive',
        stateRequirements: ['user-profile', 'subscription-status']
      },

      'mobile-optimized-view': {
        import: () => import('remote/MobileView'),
        conditions: {
          deviceType: 'mobile',
          customCondition: () => window.innerWidth < 768
        },
        mountStrategy: 'lazy',
        unmountStrategy: 'cache'
      },

      'admin-tools': {
        import: () => import('remote/AdminTools'),
        conditions: {
          userRole: ['admin', 'super-admin'],
          featureFlag: 'admin-panel'
        },
        dependencies: ['user-session', 'premium-dashboard'],
        mountStrategy: 'onDemand',
        unmountStrategy: 'destroy'
      }
    },
    globalStateManager,
    featureFlags,
    userContext
  );

  return (
    <div>
      <h1>Conditional Micro-Frontend App</h1>

      {/* Show loading states */}
      {Object.entries(moduleStates).map(([moduleId, state]) => (
        <div key={moduleId}>
          {moduleId}: {state}
        </div>
      ))}

      {/* Manual loading triggers */}
      <button onClick={() => loadModule('admin-tools')}>
        Load Admin Tools
      </button>

      <button onClick={() => unmountModule('admin-tools', 'cache')}>
        Cache Admin Tools
      </button>
    </div>
  );
};
```

### 3. Network-Aware Registry + Adaptive Lazy Loading

**Concept**: Combine dynamic registry with network-adaptive lazy loading strategies.

```tsx
// hooks/useNetworkAwareHybridLoading.ts
interface NetworkAwareConfig {
  registryUrl: string;
  adaptiveStrategies: {
    fast: 'aggressive-preload' | 'parallel-loading' | 'full-features';
    slow: 'critical-only' | 'progressive' | 'minimal-features';
    offline: 'cached-only' | 'essential-fallback';
  };
  performanceBudgets: {
    fast: { initial: number; route: number; total: number };
    slow: { initial: number; route: number; total: number };
  };
}

export const useNetworkAwareHybridLoading = (config: NetworkAwareConfig) => {
  const [networkQuality, setNetworkQuality] = useState<'fast' | 'slow' | 'offline'>('fast');
  const [currentStrategy, setCurrentStrategy] = useState(config.adaptiveStrategies.fast);
  const [performanceBudget, setPerformanceBudget] = useState(config.performanceBudgets.fast);

  // Monitor network quality
  useEffect(() => {
    const updateNetworkQuality = () => {
      if (!navigator.onLine) {
        setNetworkQuality('offline');
        return;
      }

      if ('connection' in navigator) {
        const connection = (navigator as any).connection;
        const effectiveType = connection?.effectiveType;

        if (['4g', '5g'].includes(effectiveType)) {
          setNetworkQuality('fast');
        } else {
          setNetworkQuality('slow');
        }
      }
    };

    updateNetworkQuality();
    window.addEventListener('online', updateNetworkQuality);
    window.addEventListener('offline', updateNetworkQuality);

    // Listen for connection changes
    if ('connection' in navigator) {
      (navigator as any).connection.addEventListener('change', updateNetworkQuality);
    }

    return () => {
      window.removeEventListener('online', updateNetworkQuality);
      window.removeEventListener('offline', updateNetworkQuality);
      if ('connection' in navigator) {
        (navigator as any).connection.removeEventListener('change', updateNetworkQuality);
      }
    };
  }, []);

  // Adapt strategy based on network
  useEffect(() => {
    const strategy = config.adaptiveStrategies[networkQuality];
    const budget = config.performanceBudgets[networkQuality];

    setCurrentStrategy(strategy);
    setPerformanceBudget(budget);
  }, [networkQuality, config]);

  const loadModuleAdaptively = useCallback(async (
    moduleId: string,
    priority: 'critical' | 'important' | 'optional'
  ) => {
    switch (currentStrategy) {
      case 'aggressive-preload':
        // Load everything in parallel
        return import(/* webpackChunkName: "[request]" */ `remote/${moduleId}`);

      case 'critical-only':
        // Only load critical modules
        if (priority === 'critical') {
          return import(/* webpackChunkName: "[request]" */ `remote/${moduleId}`);
        }
        return null;

      case 'progressive':
        // Load with delays based on priority
        const delay = priority === 'critical' ? 0 : priority === 'important' ? 1000 : 3000;
        await new Promise(resolve => setTimeout(resolve, delay));
        return import(/* webpackChunkName: "[request]" */ `remote/${moduleId}`);

      case 'cached-only':
        // Only use cached modules
        const cached = await caches.match(`/remote/${moduleId}`);
        if (cached) {
          return import(/* webpackChunkName: "[request]" */ `remote/${moduleId}`);
        }
        throw new Error(`Module ${moduleId} not available offline`);

      default:
        return import(/* webpackChunkName: "[request]" */ `remote/${moduleId}`);
    }
  }, [currentStrategy]);

  return {
    networkQuality,
    currentStrategy,
    performanceBudget,
    loadModuleAdaptively
  };
};
```

---

## 🧪 Complete Production Example: Multi-Strategy Integration

```tsx
// components/ProductionHybridApp.tsx
import React, { useState, useEffect, useCallback } from 'react';
import { useRegistryLazyLoading } from '../hooks/useRegistryLazyLoading';
import { useConditionalMounting } from '../hooks/useConditionalMounting';
import { useNetworkAwareHybridLoading } from '../hooks/useNetworkAwareHybridLoading';

interface ProductionConfig {
  user: {
    id: string;
    role: 'admin' | 'user' | 'guest';
    plan: 'free' | 'premium' | 'enterprise';
    permissions: string[];
  };
  featureFlags: Record<string, boolean>;
  device: {
    type: 'mobile' | 'tablet' | 'desktop';
    capabilities: {
      webgl: boolean;
      webworkers: boolean;
      storage: number;
    };
  };
}

const ProductionHybridApp: React.FC<{ config: ProductionConfig }> = ({ config }) => {
  // 1. Registry + Lazy Loading Strategy
  const registryLazyLoader = useRegistryLazyLoading({
    registryUrl: '/api/micro-frontend-registry',
    fallbackRegistry: {
      'core-platform': {
        url: 'https://cdn.example.com/core-platform',
        priority: 'critical',
        modules: {
          'Header': { path: '/header', priority: 'critical' },
          'Navigation': { path: '/navigation', priority: 'critical' },
          'Footer': { path: '/footer', priority: 'optional' }
        }
      },
      'user-management': {
        url: 'https://cdn.example.com/user-management',
        priority: 'important',
        modules: {
          'UserProfile': { path: '/profile', priority: 'important' },
          'UserSettings': { path: '/settings', priority: 'optional' }
        }
      },
      'analytics-platform': {
        url: 'https://cdn.example.com/analytics',
        priority: 'optional',
        modules: {
          'Dashboard': { path: '/dashboard', priority: 'important' },
          'Reports': { path: '/reports', priority: 'optional' },
          'RealTime': { path: '/realtime', priority: 'background' }
        }
      }
    },
    lazyLoadingStrategy: 'priority'
  });

  // 2. Conditional Mounting Strategy
  const conditionalMounter = useConditionalMounting(
    {
      'admin-panel': {
        import: () => import('remote/AdminPanel'),
        conditions: {
          userRole: ['admin'],
          featureFlag: 'admin-panel-v2'
        },
        mountStrategy: 'onDemand',
        unmountStrategy: 'cache',
        dependencies: ['user-session']
      },

      'premium-features': {
        import: () => import('remote/PremiumFeatures'),
        conditions: {
          userPlan: ['premium', 'enterprise'],
          featureFlag: 'premium-features'
        },
        mountStrategy: 'lazy',
        unmountStrategy: 'keepAlive'
      },

      'mobile-interface': {
        import: () => import('remote/MobileInterface'),
        conditions: {
          deviceType: 'mobile',
          customCondition: () => window.innerWidth < 768
        },
        mountStrategy: 'immediate',
        unmountStrategy: 'destroy'
      },

      'analytics-dashboard': {
        import: () => config.user.plan === 'enterprise'
          ? import('remote/EnterpriseAnalytics')
          : import('remote/BasicAnalytics'),
        conditions: {
          featureFlag: 'analytics-enabled',
          userPlan: ['premium', 'enterprise']
        },
        mountStrategy: 'lazy',
        unmountStrategy: 'cache',
        stateRequirements: ['user-permissions']
      }
    },
    globalStateManager,
    config.featureFlags,
    config.user
  );

  // 3. Network-Aware Loading Strategy
  const networkAwareLoader = useNetworkAwareHybridLoading({
    registryUrl: '/api/micro-frontend-registry',
    adaptiveStrategies: {
      fast: 'aggressive-preload',
      slow: 'progressive',
      offline: 'cached-only'
    },
    performanceBudgets: {
      fast: { initial: 500000, route: 300000, total: 2000000 },
      slow: { initial: 200000, route: 150000, total: 800000 }
    }
  });

  // 4. Orchestration State
  const [activeModules, setActiveModules] = useState<Set<string>>(new Set(['core-platform']));
  const [loadingProgress, setLoadingProgress] = useState<Record<string, number>>({});

  // Smart loading orchestration
  const loadModuleIntelligently = useCallback(async (
    remoteName: string,
    moduleName: string,
    trigger: 'user-action' | 'route-change' | 'background' = 'user-action'
  ) => {
    try {
      setLoadingProgress(prev => ({ ...prev, [`${remoteName}.${moduleName}`]: 0 }));

      // 1. Check network conditions and adapt strategy
      const moduleKey = `${remoteName}.${moduleName}`;

      // 2. Respect performance budget
      if (networkAwareLoader.performanceBudget) {
        const currentUsage = Object.keys(registryLazyLoader.loadedModules).length * 50000; // Estimate
        if (currentUsage > networkAwareLoader.performanceBudget.total) {
          console.warn('Performance budget exceeded, deferring load');
          return;
        }
      }

      // 3. Use registry-based lazy loading
      setLoadingProgress(prev => ({ ...prev, [moduleKey]: 30 }));
      await registryLazyLoader.loadModule(remoteName, moduleName);

      // 4. Apply conditional mounting if needed
      setLoadingProgress(prev => ({ ...prev, [moduleKey]: 60 }));
      if (conditionalMounter.moduleStates[moduleKey] !== 'mounted') {
        await conditionalMounter.loadModule(moduleKey);
      }

      // 5. Update active modules
      setLoadingProgress(prev => ({ ...prev, [moduleKey]: 100 }));
      setActiveModules(prev => new Set([...prev, moduleKey]));

      // Clean up loading state
      setTimeout(() => {
        setLoadingProgress(prev => {
          const { [moduleKey]: _, ...rest } = prev;
          return rest;
        });
      }, 1000);

    } catch (error) {
      console.error(`Failed to load ${remoteName}.${moduleName}:`, error);
      setLoadingProgress(prev => {
        const { [`${remoteName}.${moduleName}`]: _, ...rest } = prev;
        return rest;
      });
    }
  }, [registryLazyLoader, conditionalMounter, networkAwareLoader]);

  // Auto-load based on user context and network
  useEffect(() => {
    // Load critical modules immediately
    loadModuleIntelligently('core-platform', 'Header');
    loadModuleIntelligently('core-platform', 'Navigation');

    // Load contextual modules based on user
    if (config.user.role === 'admin') {
      setTimeout(() => loadModuleIntelligently('admin-panel', 'Dashboard', 'background'), 2000);
    }

    if (config.user.plan !== 'free') {
      setTimeout(() => loadModuleIntelligently('premium-features', 'Dashboard', 'background'), 3000);
    }

    // Preload likely next modules based on network
    if (networkAwareLoader.networkQuality === 'fast') {
      setTimeout(() => {
        loadModuleIntelligently('analytics-platform', 'Dashboard', 'background');
        loadModuleIntelligently('user-management', 'UserProfile', 'background');
      }, 5000);
    }
  }, [config, loadModuleIntelligently, networkAwareLoader.networkQuality]);

  return (
    <div className="production-hybrid-app">
      {/* Performance and Network Status */}
      <div className="system-status">
        <span>Network: {networkAwareLoader.networkQuality}</span>
        <span>Strategy: {networkAwareLoader.currentStrategy}</span>
        <span>Active Modules: {activeModules.size}</span>
      </div>

      {/* Loading Progress Indicators */}
      {Object.entries(loadingProgress).map(([moduleKey, progress]) => (
        <div key={moduleKey} className="loading-indicator">
          <span>{moduleKey}: {progress}%</span>
          <div className="progress-bar">
            <div
              className="progress-fill"
              style={{ width: `${progress}%` }}
            />
          </div>
        </div>
      ))}

      {/* Critical Platform Components */}
      <header>
        {registryLazyLoader.loadedModules['core-platform.Header'] && (
          <registryLazyLoader.loadedModules['core-platform.Header'].default />
        )}
      </header>

      <nav>
        {registryLazyLoader.loadedModules['core-platform.Navigation'] && (
          <registryLazyLoader.loadedModules['core-platform.Navigation'].default
            onNavigate={(route) => {
              // Trigger route-based loading
              if (route.startsWith('/admin')) {
                loadModuleIntelligently('admin-panel', 'Dashboard', 'route-change');
              }
              if (route.startsWith('/analytics')) {
                loadModuleIntelligently('analytics-platform', 'Dashboard', 'route-change');
              }
            }}
          />
        )}
      </nav>

      {/* Main Content Area */}
      <main>
        {/* User-specific content */}
        {config.user.role === 'admin' &&
         conditionalMounter.moduleStates['admin-panel'] === 'mounted' && (
          <div className="admin-section">
            <h2>Admin Panel</h2>
            {/* Admin components render here */}
          </div>
        )}

        {/* Premium features */}
        {config.user.plan !== 'free' &&
         conditionalMounter.moduleStates['premium-features'] === 'mounted' && (
          <div className="premium-section">
            <h2>Premium Features</h2>
            {/* Premium components render here */}
          </div>
        )}

        {/* Analytics dashboard */}
        {registryLazyLoader.loadedModules['analytics-platform.Dashboard'] && (
          <div className="analytics-section">
            <registryLazyLoader.loadedModules['analytics-platform.Dashboard'].default />
          </div>
        )}

        {/* Manual loading triggers */}
        <div className="manual-controls">
          <button
            onClick={() => loadModuleIntelligently('user-management', 'UserSettings')}
            disabled={registryLazyLoader.loadingStates['user-management.UserSettings']}
          >
            Load User Settings
          </button>

          <button
            onClick={() => loadModuleIntelligently('analytics-platform', 'Reports')}
            disabled={registryLazyLoader.loadingStates['analytics-platform.Reports']}
          >
            Load Reports
          </button>
        </div>
      </main>

      {/* Footer - Optional */}
      <footer>
        {registryLazyLoader.loadedModules['core-platform.Footer'] && (
          <registryLazyLoader.loadedModules['core-platform.Footer'].default />
        )}
      </footer>
    </div>
  );
};

export default ProductionHybridApp;
```

---

## 🔍 Strategy Decision Matrix

### Choosing the Right Combination

| Scenario | Primary Strategy | Secondary Strategy | Tertiary Strategy | Rationale |
|----------|-----------------|-------------------|-------------------|-----------|
| **Large Enterprise Portal** | Registry (Service Discovery) | Priority Lazy Loading | Conditional Mounting | Microservices-style scaling |
| **Multi-tenant SaaS** | Conditional Mounting | Dynamic Imports | Network-aware Loading | Tenant-specific features |
| **E-commerce Platform** | Priority Lazy Loading | Dynamic Imports | Registry (A/B Testing) | Performance-critical conversion |
| **Mobile-first App** | Network-aware Loading | Priority Lazy Loading | Conditional Mounting | Resource constraints |
| **Real-time Dashboard** | Conditional Mounting | Priority Lazy Loading | Dynamic Imports | Context-sensitive data |

---

## ✅ Best Practices for Hybrid Strategies

- [ ] **Start Simple**: Begin with one primary strategy, add secondary patterns as needed
- [ ] **Monitor Performance**: Track metrics across all combined strategies
- [ ] **Graceful Degradation**: Ensure each strategy has fallbacks when others fail
- [ ] **State Coordination**: Maintain consistent state across all loading patterns
- [ ] **Testing Strategy**: Test all combinations under different network/device conditions
- [ ] **Documentation**: Document which strategies apply to which scenarios
- [ ] **Performance Budgets**: Set and enforce budgets across all loading strategies

---

## 🚀 Quick Reference: Hybrid Combinations

```tsx
// Registry + Lazy Loading
const registryLazy = useRegistryLazyLoading(config);

// Dynamic Imports + Conditional Mounting
const conditionalDynamic = useConditionalMounting(modules, state, flags, user);

// Network-aware + All Strategies
const networkAware = useNetworkAwareHybridLoading(networkConfig);

// Complete Integration
const hybridApp = useCombinedStrategies({
  registry: registryConfig,
  lazy: lazyConfig,
  conditional: conditionalConfig,
  network: networkConfig
});
```

This completes the comprehensive guide to hybrid loading strategies, showing how to combine the individual patterns from Phase 2 into sophisticated, production-ready micro-frontend architectures.