# 2.8 Mounting Remote Apps into Host DOM

> **What you'll learn**: Advanced mounting strategies, lifecycle management, and multi-remote orchestration for complete micro-frontend applications
> üìä **Difficulty**: Intermediate | üõ†Ô∏è **Prerequisites**: 2.7 Advanced Loading Patterns

## üéØ Quick Start: Beyond Component Sharing

### The Component vs Application Problem
```tsx
// ‚ùå Limited approach - sharing individual components
const RemoteButton = lazy(() => import('remote/Button'));
const RemoteModal = lazy(() => import('remote/Modal'));

// Works for components, but what about entire applications?
// - Different routing systems
// - Independent state management
// - Separate lifecycle management
// - Multiple remotes coordination
```

### ‚úÖ Application Mounting Pattern
```tsx
// ‚úÖ Mount entire remote applications - Copy this approach
const RemoteShoppingCart = lazy(() => import('remote/ShoppingCartApp'));
const RemoteDashboard = lazy(() => import('remote/DashboardApp'));

// Each remote app manages its own:
// - Routes (internal navigation)
// - State (Redux, Zustand, Context)
// - Lifecycle (mount/unmount)
// - Dependencies

// Container approach for full app control
const AppDashboard = () => (
  <div className="app-grid">
    <RemoteAppContainer appName="ecommerce" mountPath="/store" />
    <RemoteAppContainer appName="analytics" mountPath="/charts" />
  </div>
);
```

‚úÖ **Test It Works**:
```bash
# 1. Start host and remote from previous exercises
# 2. Visit http://localhost:3000 - see multiple app instances
# 3. Each remote should render independently
# 4. Navigate within one remote - others stay unaffected
# 5. Check browser console for mount/unmount lifecycle logs

# Validation commands:
curl -s http://localhost:3000 | grep -o "data-app" | wc -l
# Should show number of mounted remote apps
```

---

## üèóÔ∏è Mounting Strategies

**What**: Different approaches to integrate complete remote applications into host applications
**Why**: Each strategy solves specific architectural needs - from simple embedding to complex orchestration
**When**: Choose based on your requirements for isolation, control, and complexity

### 1. Container-Based Mounting

**Concept**: Wrap each remote app in a dedicated container component that manages its lifecycle independently.

**What it does**:
- Creates isolated DOM containers for each remote app
- Manages mount/unmount lifecycle automatically
- Provides error boundaries and loading states
- Enables multiple instances of the same remote app

**Why use it**:
- Maximum isolation between apps
- Clean lifecycle management
- Easy to implement and debug
- Reusable across different contexts

**When to use**:
- You need multiple instances of remote apps
- Each app should be completely independent
- You want simple, predictable behavior
- Testing and debugging are priorities

```tsx
// containers/RemoteAppContainer.tsx
import React, { useEffect, useRef, useState } from 'react';

interface RemoteAppContainerProps {
  appName: string;
  mountPath: string;
  initialProps?: Record<string, any>;
  onMount?: () => void;
  onUnmount?: () => void;
}

export const RemoteAppContainer: React.FC<RemoteAppContainerProps> = ({
  appName,
  mountPath,
  initialProps = {},
  onMount,
  onUnmount
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [mountState, setMountState] = useState<'loading' | 'mounted' | 'error'>('loading');

  useEffect(() => {
    let isMounted = true;

    const mountRemoteApp = async () => {
      try {
        // Import the remote app's mount function
        const { mount, unmount } = await import(`${appName}/bootstrap`);

        if (!isMounted) return;

        // Mount the remote app
        await mount(containerRef.current, {
          initialPath: mountPath,
          props: initialProps,
          onNavigate: (path: string) => {
            console.log(`${appName} navigated to: ${path}`);
          }
        });

        setMountState('mounted');
        onMount?.();

        // Return cleanup function
        return () => {
          if (unmount) {
            unmount(containerRef.current);
          }
          onUnmount?.();
        };
      } catch (error) {
        console.error(`Failed to mount ${appName}:`, error);
        setMountState('error');
      }
    };

    const cleanup = mountRemoteApp();

    return () => {
      isMounted = false;
      cleanup?.then(cleanupFn => cleanupFn?.());
    };
  }, [appName, mountPath, initialProps, onMount, onUnmount]);

  if (mountState === 'error') {
    return (
      <div className="remote-app-error">
        <p>Failed to load {appName}</p>
        <button onClick={() => window.location.reload()}>Retry</button>
      </div>
    );
  }

  return (
    <div
      ref={containerRef}
      className={`remote-app-container ${appName}`}
      data-app={appName}
      data-state={mountState}
    />
  );
};
```

### 2. Route-Based Mounting

**Concept**: Map entire URL paths to specific remote applications, giving each app complete control over its route space.

**What it does**:
- Assigns URL patterns to remote applications (e.g., `/shop/*` ‚Üí ecommerce app)
- Remote apps handle their internal routing independently
- Host router delegates control to remote apps
- Enables deep linking into remote app features

**Why use it**:
- Natural URL structure (users see logical paths)
- Remote apps control their own navigation
- SEO-friendly with proper URL hierarchy
- Easy to reason about for users and developers

**When to use**:
- Each remote app represents a distinct business domain
- You want clean, hierarchical URLs
- Remote apps need full routing autonomy
- SEO and deep linking are important

```tsx
// routing/RemoteAppRouter.tsx
import React, { Suspense } from 'react';
import { Route, Routes, useLocation } from 'react-router-dom';
import { RemoteAppContainer } from '../containers/RemoteAppContainer';

interface RemoteRoute {
  path: string;
  appName: string;
  fallback?: React.ComponentType;
}

const remoteRoutes: RemoteRoute[] = [
  { path: '/shopping/*', appName: 'ecommerce', fallback: ShoppingFallback },
  { path: '/dashboard/*', appName: 'analytics', fallback: DashboardFallback },
  { path: '/profile/*', appName: 'userprofile' }
];

export const RemoteAppRouter: React.FC = () => {
  const location = useLocation();

  return (
    <Routes>
      {remoteRoutes.map(({ path, appName, fallback: Fallback }) => (
        <Route
          key={path}
          path={path}
          element={
            <Suspense fallback={<div>Loading {appName}...</div>}>
              <RemoteAppContainer
                appName={appName}
                mountPath={location.pathname}
                onMount={() => console.log(`${appName} mounted at ${path}`)}
              />
              {Fallback && (
                <div className="remote-fallback">
                  <Fallback />
                </div>
              )}
            </Suspense>
          }
        />
      ))}
    </Routes>
  );
};
```

### 3. Dynamic Mounting with Registry

**Concept**: Centralized registry system that dynamically loads and manages remote applications based on configuration.

**What it does**:
- Maintains a registry of available remote applications
- Dynamically loads remote apps when needed
- Handles version management and dependencies
- Provides programmatic control over app lifecycle

**Why use it**:
- Runtime flexibility - add/remove apps without code changes
- Version management and A/B testing capabilities
- Centralized configuration and monitoring
- Advanced features like dependency management

**When to use**:
- You need runtime control over which apps load
- Version management and rollback capabilities are required
- You're building a plugin-style architecture
- Advanced orchestration features are needed

```tsx
// registry/RemoteAppRegistry.tsx
interface RemoteAppConfig {
  name: string;
  url: string;
  scope: string;
  module: string;
  mountStrategy: 'container' | 'route' | 'portal';
  dependencies?: string[];
  version?: string;
}

class RemoteAppRegistry {
  private apps = new Map<string, RemoteAppConfig>();
  private mounted = new Map<string, any>();

  register(config: RemoteAppConfig) {
    this.apps.set(config.name, config);
  }

  async mount(appName: string, container: HTMLElement, options: any = {}) {
    const config = this.apps.get(appName);
    if (!config) {
      throw new Error(`Remote app ${appName} not registered`);
    }

    try {
      // Load the remote app
      await this.loadRemoteApp(config);

      // Get the mount function
      const remoteApp = await this.getRemoteApp(config);

      // Mount the app
      const instance = await remoteApp.mount(container, options);
      this.mounted.set(appName, instance);

      return instance;
    } catch (error) {
      console.error(`Failed to mount ${appName}:`, error);
      throw error;
    }
  }

  async unmount(appName: string) {
    const instance = this.mounted.get(appName);
    if (instance && instance.unmount) {
      await instance.unmount();
      this.mounted.delete(appName);
    }
  }

  private async loadRemoteApp(config: RemoteAppConfig) {
    // Dynamic import of remote entry
    const script = document.createElement('script');
    script.src = `${config.url}/remoteEntry.js`;

    return new Promise((resolve, reject) => {
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  private async getRemoteApp(config: RemoteAppConfig) {
    // @ts-ignore
    return await window[config.scope].get(config.module);
  }
}

export const remoteRegistry = new RemoteAppRegistry();

// Register remote apps
remoteRegistry.register({
  name: 'ecommerce',
  url: 'http://localhost:3001',
  scope: 'ecommerce',
  module: './App',
  mountStrategy: 'route'
});

remoteRegistry.register({
  name: 'analytics',
  url: 'http://localhost:3002',
  scope: 'analytics',
  module: './Dashboard',
  mountStrategy: 'container'
});
```

---

## üéØ 30-Second Quick Wins

### Instant App Mounting
```tsx
// Replace any lazy component with full app mounting - 3 lines
const ShoppingApp = () => (
  <RemoteAppContainer appName="ecommerce" mountPath="/products" />
);
// ‚úÖ Now you have a complete app, not just a component!
```

### Route-Level Mounting
```tsx
// Mount entire remote apps on routes - 1 line change
<Route path="/shop/*" element={
  <RemoteAppContainer appName="ecommerce" mountPath="/shop" />
} />
// ‚úÖ Entire ecommerce app now owns the /shop/* route space
```

### Multiple Apps Side-by-Side
```tsx
// Mount multiple remotes simultaneously - copy/paste ready
const Dashboard = () => (
  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr' }}>
    <RemoteAppContainer appName="analytics" mountPath="/charts" />
    <RemoteAppContainer appName="notifications" mountPath="/alerts" />
  </div>
);
// ‚úÖ Two independent apps running simultaneously
```

### Lifecycle Control
```tsx
// Control when apps load/unload - 2 lines
const [showApp, setShowApp] = useState(false);
{showApp && <RemoteAppContainer appName="analytics" mountPath="/dash" />}
// ‚úÖ Toggle apps on/off with zero memory leaks
```

---

## üîÑ Lifecycle Management

**What**: Coordinating the creation, execution, and cleanup phases of remote applications
**Why**: Prevents memory leaks, ensures clean state management, and enables proper resource cleanup
**When**: Essential for any production micro-frontend implementation

**Core Concepts**:
- **Mount**: Initialize remote app in host DOM with proper context
- **Update**: Respond to prop changes and state updates
- **Unmount**: Clean up resources, event listeners, and memory
- **Error Recovery**: Handle failures gracefully without breaking the host

### 1. Mount/Unmount Coordination

**Concept**: Think of this like safely plugging and unplugging electrical devices - you need proper procedures to avoid damage.

**The Problem**:
When you show/hide remote apps in React, you're not just toggling visibility. You're actually:
- Starting entire React applications inside your host app
- Each remote app creates its own React roots, event listeners, timers, etc.
- When you "remove" the component, React unmounts it, but the remote app might keep running in the background

**Real-World Example**:
```tsx
// ‚ùå Bad: This looks innocent but creates problems
const Dashboard = () => {
  const [showEcommerce, setShowEcommerce] = useState(false);

  return (
    <div>
      {showEcommerce && <RemoteEcommerceApp />}
      <button onClick={() => setShowEcommerce(!showEcommerce)}>
        Toggle Store
      </button>
    </div>
  );
};

// Problem: When showEcommerce becomes false:
// - React unmounts the component
// - But the remote app's timers, API calls, event listeners keep running
// - Memory leaks and potential crashes
```

**The Solution - Mount/Unmount Coordination**:
```tsx
// ‚úÖ Good: Proper coordination ensures clean startup and shutdown
const Dashboard = () => {
  const [showEcommerce, setShowEcommerce] = useState(false);

  return (
    <div>
      {showEcommerce && (
        <RemoteAppContainer
          appName="ecommerce"
          onMount={() => console.log('Store started safely')}
          onUnmount={() => console.log('Store stopped cleanly')}
        />
      )}
    </div>
  );
};
```

**What Mount/Unmount Coordination Actually Does**:
```
When mounting:
1. "Hey remote app, start up in this DOM container"
2. "Here's your configuration and props"
3. "Please give me a cleanup function for later"

When unmounting:
1. "Time to shut down - run your cleanup function"
2. "Stop all timers, cancel API calls, remove listeners"
3. "Release all memory and resources"
4. "Remove yourself from the DOM completely"
```

**Why This Matters**:
Without proper coordination, toggling remote apps creates memory leaks, performance issues, and potential crashes. With coordination, apps start and stop cleanly like well-behaved plugins.

```tsx
// hooks/useRemoteAppLifecycle.ts
import { useEffect, useRef, useState } from 'react';

interface LifecycleOptions {
  preload?: boolean;
  keepAlive?: boolean;
  timeout?: number;
}

export const useRemoteAppLifecycle = (
  appName: string,
  options: LifecycleOptions = {}
) => {
  const [state, setState] = useState<'idle' | 'loading' | 'mounted' | 'error'>('idle');
  const instanceRef = useRef<any>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const mount = async (mountOptions: any = {}) => {
    if (state === 'mounted') return;

    setState('loading');
    try {
      instanceRef.current = await remoteRegistry.mount(
        appName,
        containerRef.current!,
        mountOptions
      );
      setState('mounted');
    } catch (error) {
      setState('error');
      throw error;
    }
  };

  const unmount = async () => {
    if (state !== 'mounted') return;

    try {
      await remoteRegistry.unmount(appName);
      instanceRef.current = null;
      setState('idle');
    } catch (error) {
      console.error(`Failed to unmount ${appName}:`, error);
    }
  };

  // Preload if requested
  useEffect(() => {
    if (options.preload) {
      mount();
    }
  }, [options.preload]);

  // Cleanup on unmount (unless keepAlive)
  useEffect(() => {
    return () => {
      if (!options.keepAlive) {
        unmount();
      }
    };
  }, [options.keepAlive]);

  return {
    state,
    mount,
    unmount,
    containerRef,
    instance: instanceRef.current
  };
};
```

### 2. State Synchronization

**Concept**: Enabling communication and shared state between independent remote applications.

**The Challenge**:
Remote apps are isolated by design, but often need to share information:
- User authentication status across all apps
- Shopping cart data between catalog and checkout
- Theme preferences and UI settings
- Real-time notifications and alerts

**What state synchronization provides**:
- **Event-driven communication**: Apps can emit and listen to events
- **Shared data layer**: Common state accessible to all apps
- **Loose coupling**: Apps remain independent while sharing necessary data
- **Real-time updates**: Changes in one app propagate to others

**Why not just use props**:
- Props are one-way and limited to parent-child relationships
- Remote apps may need to communicate peer-to-peer
- Dynamic relationships (apps loading/unloading) are hard to manage with props
- Events provide more flexible, scalable communication patterns

```tsx
// communication/AppBridge.ts
type EventPayload = Record<string, any>;
type EventHandler = (payload: EventPayload) => void;

class AppBridge {
  private listeners = new Map<string, EventHandler[]>();

  // Cross-app communication
  emit(event: string, payload: EventPayload) {
    const handlers = this.listeners.get(event) || [];
    handlers.forEach(handler => handler(payload));

    // Also emit to all mounted remote apps
    this.broadcastToRemotes(event, payload);
  }

  on(event: string, handler: EventHandler) {
    const handlers = this.listeners.get(event) || [];
    handlers.push(handler);
    this.listeners.set(event, handlers);

    return () => {
      const currentHandlers = this.listeners.get(event) || [];
      const index = currentHandlers.indexOf(handler);
      if (index > -1) {
        currentHandlers.splice(index, 1);
      }
    };
  }

  private broadcastToRemotes(event: string, payload: EventPayload) {
    // Send event to all mounted remote apps
    window.postMessage({
      type: 'BRIDGE_EVENT',
      event,
      payload,
      source: 'host'
    }, '*');
  }

  // Remote apps can also emit events
  constructor() {
    window.addEventListener('message', (event) => {
      if (event.data.type === 'BRIDGE_EVENT' && event.data.source === 'remote') {
        this.emit(event.data.event, event.data.payload);
      }
    });
  }
}

export const appBridge = new AppBridge();

// Usage in host
appBridge.on('user-login', (user) => {
  console.log('User logged in across all apps:', user);
});

// Usage in remote
appBridge.emit('cart-updated', { items: 3, total: 99.99 });
```

---

## üõ†Ô∏è Remote App Implementation

**What**: How to structure remote applications to be mountable by host applications
**Why**: Remote apps need special bootstrap code to work in both standalone and federated modes
**When**: Required for every remote app that will be mounted by hosts

**Key Requirements for Remote Apps**:
1. **Dual Mode Support**: Work standalone (development) and as mounted app (production)
2. **Mount/Unmount API**: Expose functions for lifecycle management
3. **Context Awareness**: Accept props and configuration from host
4. **Clean Cleanup**: Properly dispose of resources when unmounted

### 1. Remote App Bootstrap

**Concept**: The bootstrap pattern provides a standardized way for remote apps to expose mounting capabilities.

**What the bootstrap does**:
- Provides a `mount()` function that hosts can call
- Handles React root creation and management
- Returns cleanup functions for proper unmounting
- Supports both development (standalone) and production (federated) modes

**Why this pattern**:
- **Standardization**: All remote apps follow the same interface
- **Flexibility**: Supports different mounting contexts and props
- **Development Experience**: Apps can run standalone during development
- **Production Ready**: Clean integration with host applications

```tsx
// remote-ecommerce/src/bootstrap.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';

// Mount function for host integration
export const mount = async (container: HTMLElement, options: any = {}) => {
  const root = createRoot(container);

  root.render(
    <BrowserRouter basename={options.initialPath || '/'}>
      <App {...options.props} />
    </BrowserRouter>
  );

  // Return cleanup function
  return {
    unmount: () => {
      root.unmount();
    },
    update: (newProps: any) => {
      root.render(
        <BrowserRouter basename={options.initialPath || '/'}>
          <App {...newProps} />
        </BrowserRouter>
      );
    }
  };
};

// Standalone mode for development
if (process.env.NODE_ENV === 'development') {
  const container = document.getElementById('root');
  if (container) {
    mount(container);
  }
}
```

### 2. Remote App with Internal Routing

**Concept**: Remote applications that manage their own internal navigation while being embedded in host applications.

**The Routing Challenge**:
- Host app has its own router and URL structure
- Remote app needs its own internal navigation
- Both routers must coexist without conflicts
- Deep linking should work for remote app routes

**How Internal Routing Works**:
- Remote app receives a `basename` prop from the host
- Remote app's router uses this basename for all its routes
- Host delegates URL control to remote for specific path patterns
- Both apps maintain their routing independence

**Benefits**:
- **Autonomy**: Remote teams control their app's navigation
- **Deep Linking**: Users can bookmark remote app pages
- **SEO**: Search engines can index remote app routes
- **Development**: Remote app works standalone with full routing

```tsx
// remote-ecommerce/src/App.tsx
import React from 'react';
import { Routes, Route, Link } from 'react-router-dom';
import { ProductList } from './components/ProductList';
import { ProductDetail } from './components/ProductDetail';
import { Cart } from './components/Cart';

const App: React.FC = () => {
  return (
    <div className="ecommerce-app">
      <nav className="ecommerce-nav">
        <Link to="/products">Products</Link>
        <Link to="/cart">Cart</Link>
      </nav>

      <Routes>
        <Route path="/" element={<ProductList />} />
        <Route path="/products" element={<ProductList />} />
        <Route path="/products/:id" element={<ProductDetail />} />
        <Route path="/cart" element={<Cart />} />
      </Routes>
    </div>
  );
};

export default App;
```

### 3. Webpack Configuration for Remote App

```js
// remote-ecommerce/webpack.config.js
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  mode: 'development',
  devServer: { port: 3001 },
  plugins: [
    new ModuleFederationPlugin({
      name: 'ecommerce',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App',
        './bootstrap': './src/bootstrap' // Expose bootstrap for mounting
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
        'react-router-dom': { singleton: true }
      },
    }),
  ],
};
```

---

## üåê Multi-Remote Orchestration

**What**: Coordinating multiple remote applications to work together as a unified system
**Why**: Real applications often need multiple micro-frontends working in harmony
**When**: Building dashboards, workspaces, or any multi-domain application

**Orchestration Challenges**:
- **Layout Management**: Positioning multiple apps in a coherent interface
- **State Coordination**: Sharing data between independent applications
- **Resource Management**: Preventing conflicts and optimizing performance
- **User Experience**: Making multiple apps feel like a single application

**Orchestration Patterns**:
- **Dashboard Pattern**: Multiple apps in a grid or layout system
- **Workspace Pattern**: Apps that can be added, removed, and rearranged
- **Master-Detail Pattern**: One app controls others (e.g., list + detail views)
- **Wizard Pattern**: Sequential flow through multiple apps

### 1. Orchestrator Component

**Concept**: A master component that manages the layout, lifecycle, and coordination of multiple remote applications.

**What an orchestrator does**:
- Manages the layout and positioning of multiple remote apps
- Coordinates shared state and communication between apps
- Handles dynamic loading and unloading of applications
- Provides a unified user experience across multiple apps

**Key Responsibilities**:
- **Layout Management**: Window/panel positioning and sizing
- **State Synchronization**: Sharing data across apps
- **Communication Hub**: Routing messages between applications
- **Resource Coordination**: Managing memory and performance

```tsx
// orchestration/MicroFrontendOrchestrator.tsx
import React, { useState, useEffect } from 'react';
import { RemoteAppContainer } from '../containers/RemoteAppContainer';

interface RemoteAppInstance {
  id: string;
  appName: string;
  mountPath: string;
  props?: any;
  position: { x: number; y: number; width: string; height: string };
}

export const MicroFrontendOrchestrator: React.FC = () => {
  const [remoteApps, setRemoteApps] = useState<RemoteAppInstance[]>([
    {
      id: 'ecommerce-1',
      appName: 'ecommerce',
      mountPath: '/products',
      position: { x: 0, y: 0, width: '50%', height: '100%' }
    },
    {
      id: 'analytics-1',
      appName: 'analytics',
      mountPath: '/dashboard',
      position: { x: 50, y: 0, width: '50%', height: '50%' }
    },
    {
      id: 'notifications-1',
      appName: 'notifications',
      mountPath: '/alerts',
      position: { x: 50, y: 50, width: '50%', height: '50%' }
    }
  ]);

  const [globalState, setGlobalState] = useState({
    user: null,
    theme: 'light',
    language: 'en'
  });

  // Listen for state changes from remote apps
  useEffect(() => {
    const unsubscribe = appBridge.on('state-change', (payload) => {
      setGlobalState(prev => ({ ...prev, ...payload }));
    });

    return unsubscribe;
  }, []);

  return (
    <div className="orchestrator-container">
      <header className="orchestrator-header">
        <h1>Multi-App Dashboard</h1>
        <div className="global-state">
          User: {globalState.user?.name || 'Guest'} |
          Theme: {globalState.theme}
        </div>
      </header>

      <div className="apps-container">
        {remoteApps.map((app) => (
          <div
            key={app.id}
            className="app-window"
            style={{
              position: 'absolute',
              left: `${app.position.x}%`,
              top: `${app.position.y}%`,
              width: app.position.width,
              height: app.position.height,
              border: '1px solid #ccc',
              borderRadius: '8px',
              overflow: 'hidden'
            }}
          >
            <div className="app-header">
              <span>{app.appName}</span>
              <button onClick={() => removeApp(app.id)}>√ó</button>
            </div>

            <RemoteAppContainer
              appName={app.appName}
              mountPath={app.mountPath}
              initialProps={{
                ...app.props,
                globalState,
                onStateChange: (state: any) => {
                  appBridge.emit('state-change', state);
                }
              }}
            />
          </div>
        ))}
      </div>
    </div>
  );

  function removeApp(appId: string) {
    setRemoteApps(prev => prev.filter(app => app.id !== appId));
  }
};
```

---

## üß™ Complete Production Example

```tsx
// pages/MultiAppDashboard.tsx
import React, { useState, useEffect } from 'react';
import { RemoteAppContainer } from '../containers/RemoteAppContainer';
import { useRemoteAppLifecycle } from '../hooks/useRemoteAppLifecycle';
import { appBridge } from '../communication/AppBridge';

export const MultiAppDashboard: React.FC = () => {
  const [activeApps, setActiveApps] = useState<string[]>(['ecommerce']);
  const [globalUser, setGlobalUser] = useState(null);

  // Lifecycle management for each app
  const ecommerceApp = useRemoteAppLifecycle('ecommerce', { preload: true });
  const analyticsApp = useRemoteAppLifecycle('analytics');
  const profileApp = useRemoteAppLifecycle('userprofile');

  // Cross-app communication
  useEffect(() => {
    const unsubscribeLogin = appBridge.on('user-login', (user) => {
      setGlobalUser(user);
      // Notify all apps of login
      activeApps.forEach(appName => {
        appBridge.emit(`${appName}-user-update`, user);
      });
    });

    const unsubscribeLogout = appBridge.on('user-logout', () => {
      setGlobalUser(null);
      // Notify all apps of logout
      activeApps.forEach(appName => {
        appBridge.emit(`${appName}-user-update`, null);
      });
    });

    return () => {
      unsubscribeLogin();
      unsubscribeLogout();
    };
  }, [activeApps]);

  const toggleApp = async (appName: string) => {
    if (activeApps.includes(appName)) {
      setActiveApps(prev => prev.filter(name => name !== appName));

      // Unmount the app
      switch (appName) {
        case 'analytics':
          await analyticsApp.unmount();
          break;
        case 'userprofile':
          await profileApp.unmount();
          break;
      }
    } else {
      setActiveApps(prev => [...prev, appName]);

      // Mount the app
      switch (appName) {
        case 'analytics':
          await analyticsApp.mount({ user: globalUser });
          break;
        case 'userprofile':
          await profileApp.mount({ user: globalUser });
          break;
      }
    }
  };

  return (
    <div className="multi-app-dashboard">
      <header>
        <h1>Micro-Frontend Dashboard</h1>
        <div className="app-toggles">
          <button
            onClick={() => toggleApp('analytics')}
            className={activeApps.includes('analytics') ? 'active' : ''}
          >
            Toggle Analytics
          </button>
          <button
            onClick={() => toggleApp('userprofile')}
            className={activeApps.includes('userprofile') ? 'active' : ''}
          >
            Toggle Profile
          </button>
        </div>
      </header>

      <main className="dashboard-grid">
        {/* Always show ecommerce */}
        <section className="app-section main">
          <h2>E-commerce Store</h2>
          <div ref={ecommerceApp.containerRef} />
          {ecommerceApp.state === 'loading' && <div>Loading store...</div>}
          {ecommerceApp.state === 'error' && <div>Store unavailable</div>}
        </section>

        {/* Conditionally show analytics */}
        {activeApps.includes('analytics') && (
          <section className="app-section sidebar">
            <h2>Analytics Dashboard</h2>
            <div ref={analyticsApp.containerRef} />
            {analyticsApp.state === 'loading' && <div>Loading analytics...</div>}
          </section>
        )}

        {/* Conditionally show profile */}
        {activeApps.includes('userprofile') && (
          <section className="app-section sidebar">
            <h2>User Profile</h2>
            <div ref={profileApp.containerRef} />
            {profileApp.state === 'loading' && <div>Loading profile...</div>}
          </section>
        )}
      </main>
    </div>
  );
};
```

---

## üß™ Hands-On Exercise

**Challenge**: Create a multi-app dashboard with lifecycle management

### Step 1: Create Remote App Bootstrap
```tsx
// In your remote app from 2.6, create src/bootstrap.tsx
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

export const mount = async (container: HTMLElement, options: any = {}) => {
  const root = createRoot(container);
  root.render(<App {...options.props} />);

  return {
    unmount: () => root.unmount()
  };
};

// Update webpack.config.js to expose bootstrap
exposes: {
  './App': './src/App',
  './bootstrap': './src/bootstrap'
}
```

### Step 2: Create Container in Host
```tsx
// In your host app, create RemoteAppContainer component
// Copy the container implementation from above
```

### Step 3: Test Multi-App Setup
```tsx
// Replace your basic remote usage with:
<div className="dashboard">
  <RemoteAppContainer
    appName="remote"
    mountPath="/app1"
  />
  <RemoteAppContainer
    appName="remote"
    mountPath="/app2"
  />
</div>
```

### Step 4: Verify Independent Instances
```bash
# 1. Visit http://localhost:3000 - see both instances
# 2. Open DevTools Console - look for mount logs
# 3. Check React DevTools - each app has separate component tree
# 4. Test independence: interact with one, other stays unchanged

# Advanced validation:
document.querySelectorAll('[data-app]').length // Should show 2
// Each instance should be independent React trees
```

‚úÖ **Success Criteria**: Multiple independent remote app instances running simultaneously with proper lifecycle management

### Debugging Tips
```tsx
// Add logging to verify mounting
export const mount = async (container, options = {}) => {
  console.log('üöÄ Mounting remote app:', container, options);
  const root = createRoot(container);
  root.render(<App {...options.props} />);

  return {
    unmount: () => {
      console.log('üî• Unmounting remote app');
      root.unmount();
    }
  };
};
```

---

## ‚ö†Ô∏è Common Pitfalls & Solutions

### Problem: "Cannot read properties of null (reading 'render')"

**Cause**: Container element not available when mounting
**Solution**:
```tsx
// ‚ùå Wrong - mounting too early
useEffect(() => {
  mount(containerRef.current); // containerRef.current might be null
}, []);

// ‚úÖ Right - check container exists
useEffect(() => {
  if (containerRef.current) {
    mount(containerRef.current);
  }
}, [containerRef.current]);
```

### Problem: Memory leaks when switching apps

**Cause**: Not properly unmounting previous instances
**Solution**:
```tsx
// ‚úÖ Always cleanup previous instance
useEffect(() => {
  let cleanup: (() => void) | undefined;

  mount(container).then(instance => {
    cleanup = instance.unmount;
  });

  return () => cleanup?.();
}, [appName]);
```

### Problem: Apps interfering with each other's styles

**Cause**: CSS bleeding between apps
**Solution**:
```tsx
// ‚úÖ Scope styles per app
.remote-app-container[data-app="ecommerce"] {
  /* Styles only for ecommerce app */
}

.remote-app-container[data-app="analytics"] {
  /* Styles only for analytics app */
}
```

---

## ‚úÖ Best Practices Checklist

- [ ] **Bootstrap Pattern**: Remote apps expose mount/unmount functions
- [ ] **Lifecycle Management**: Proper cleanup on unmount
- [ ] **Independent State**: Each instance maintains separate state
- [ ] **Communication Bridge**: Cross-app event system
- [ ] **Error Boundaries**: Isolate failures between apps
- [ ] **Resource Management**: Prevent memory leaks
- [ ] **Registry Pattern**: Centralized app configuration
- [ ] **Route Integration**: Seamless routing coordination

---

## üîç Key Concepts Summary

| Concept | Definition | Example |
|---------|------------|---------|
| **App Mounting** | Loading complete applications vs components | `mount(container, options)` |
| **Lifecycle Management** | Coordinating mount/unmount across apps | `useRemoteAppLifecycle` hook |
| **App Bridge** | Communication system between apps | `appBridge.emit('event', data)` |
| **Registry Pattern** | Centralized app configuration and loading | `remoteRegistry.register(config)` |
| **Orchestration** | Managing multiple apps simultaneously | Multi-app dashboard |

---

## üìñ Learning Path & Next Steps

### ‚úÖ **Mastery Checklist - You Can Now:**

- [ ] Mount complete remote applications (not just components)
- [ ] Implement proper lifecycle management for remote apps
- [ ] Coordinate multiple remote apps simultaneously
- [ ] Build communication bridges between apps
- [ ] Handle independent routing within remote apps
- [ ] Create production-ready app orchestration
- [ ] Manage state synchronization across apps

### üîú **Next Topic**: [2.9 Dynamic Imports vs Static Imports](./2.9-dynamic-vs-static-imports.md)

**What you'll learn**: Performance optimization strategies, import timing decisions, and bundle splitting techniques

### üîÆ **Your Learning Journey**:

```
Basic Setup ‚Üí Advanced Loading ‚Üí App Mounting (You are here!) ‚Üí Performance Optimization
```

---

## üöÄ Quick Reference Card

### Essential Patterns
```tsx
// Remote app bootstrap
export const mount = (container, options) => {
  const root = createRoot(container);
  root.render(<App {...options} />);
  return { unmount: () => root.unmount() };
};

// App container
<RemoteAppContainer
  appName="ecommerce"
  mountPath="/products"
  onMount={() => console.log('mounted')}
/>

// Multi-app coordination
const apps = ['ecommerce', 'analytics', 'profile'];
apps.forEach(app => remoteRegistry.mount(app, container));
```

### Communication Bridge
```tsx
// Cross-app events
appBridge.emit('user-login', user);
appBridge.on('cart-update', handleCartChange);

// State synchronization
const globalState = useGlobalState();
<RemoteApp initialProps={{ globalState }} />
```

---

## üìö References

- [Module Federation Advanced Patterns](https://module-federation.io/guide/basic/host.html)
- [Micro-Frontend Communication Patterns](https://martinfowler.com/articles/micro-frontends.html)
- [React 18 Concurrent Features](https://react.dev/blog/2022/03/29/react-v18)
- [Application Lifecycle Management](https://web.dev/app-lifecycle/)