# 5.19 Environment-based Remote Loading (dev, staging, prod)

> **What you'll learn**: How to load remote micro-frontends from different URLs based on your deployment environment, without hardcoding production URLs into your development code

---

## 🤔 Why This Matters

### The Problem
Imagine you're developing a micro-frontend host app on your laptop. You configure it to load a remote app:

```js
remotes: {
  remoteApp: 'remoteApp@http://localhost:3001/remoteEntry.js'  // ❌ This breaks in production!
}
```

This works locally, but when you deploy to production, your app is still trying to reach `localhost:3001` - which doesn't exist on your user's browser! You need the production build to point to `https://remote.example.com` instead.

### The Challenge
You have **one codebase** but need **different remote URLs** depending on where it's running:

| Environment | Remote URL | When Used |
|-------------|-----------|-----------|
| **Development** | `http://localhost:3001` | Your laptop while coding |
| **Staging** | `https://staging-remote.example.com` | QA testing environment |
| **Production** | `https://remote.example.com` | Live site for real users |

**The goal**: Write your code once, but have it automatically use the right URL for each environment.

---

## 💡 The Two Main Approaches

Before diving into code, understand there are **two fundamentally different strategies** for solving this problem. Choosing the right one depends on your deployment workflow.

### Approach 1: Compile-Time Configuration (Most Common)
**How it works**: The remote URL is "baked into" your JavaScript bundle when you build it.

**When you'd use it**:
- You build separate bundles for dev/staging/prod (e.g., `yarn build:dev`, `yarn build:prod`)
- Your CI/CD pipeline creates environment-specific builds
- You're okay rebuilding to change which remote URL is used

**Pros**:
✅ Simpler code - just use normal `import()` statements
✅ Type-safe - TypeScript knows about your remotes at compile time
✅ Faster runtime - no extra network requests for configuration

**Cons**:
❌ Need to rebuild to switch environments
❌ Can't change remote URLs after deployment (without rebuilding)

---

### Approach 2: Runtime Configuration (More Flexible)
**How it works**: Your app fetches a configuration file or API when it first loads, then uses that to determine remote URLs.

**When you'd use it**:
- You want one build that works in all environments
- You need to change remote URLs without redeploying (e.g., for A/B testing)
- You have a centralized config server
- You want feature flags to enable/disable remotes

**Pros**:
✅ One build for all environments
✅ Can update remote URLs without rebuilding
✅ Enables advanced scenarios (feature flags, A/B testing)

**Cons**:
❌ More complex code - manual remote loading
❌ Slower startup - must fetch config first
❌ Requires runtime infrastructure (config server or static config files)

### Visual Comparison

```
┌─────────────────────────────────────────────────────────────────────┐
│                    COMPILE-TIME CONFIGURATION                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Development Build          Staging Build          Production Build │
│  ┌──────────────┐          ┌──────────────┐       ┌──────────────┐ │
│  │ webpack.config│          │ webpack.config│       │ webpack.config│ │
│  │ + .env.dev    │──────▶  │ + .env.staging│─────▶│ + .env.prod   │ │
│  └──────────────┘          └──────────────┘       └──────────────┘ │
│         │                          │                      │         │
│         ▼                          ▼                      ▼         │
│  ┌──────────────┐          ┌──────────────┐       ┌──────────────┐ │
│  │ main.js      │          │ main.js      │       │ main.js      │ │
│  │ localhost:   │          │ staging.com  │       │ example.com  │ │
│  │ 3001 ←───────┼──────────┼──────────────┼───────┼──────────────┤ │
│  └──────────────┘  Hardcoded URLs different in each build         │
│                                                                      │
│  ✅ Simple  ✅ Fast  ❌ Must rebuild to change URLs                  │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                     RUNTIME CONFIGURATION                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│              ONE Build for ALL Environments                          │
│              ┌──────────────┐                                        │
│              │ webpack.config│                                       │
│              │ (no env vars) │                                       │
│              └──────────────┘                                        │
│                      │                                               │
│                      ▼                                               │
│              ┌──────────────┐                                        │
│              │ main.js      │ ←─── Same bundle deployed everywhere  │
│              │ (generic)    │                                        │
│              └──────┬───────┘                                        │
│                     │                                                │
│         ┌───────────┼───────────┐                                   │
│         ▼           ▼           ▼                                    │
│  Dev Server   Staging Server   Prod Server                          │
│  Serves:      Serves:          Serves:                              │
│  dev.json     staging.json     prod.json                            │
│  localhost    staging.com      example.com                          │
│                                                                      │
│  ✅ Flexible  ✅ One build  ❌ Complex  ❌ Slower startup             │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 🚀 Quick Start: Compile-Time Configuration

This is the approach **most teams start with** because it's simpler. We'll use environment variables that get replaced during the build.

### Step 1: Create Environment Variable Files

Create three files in your host app's root directory:

```bash
# .env.development
NODE_ENV=development
REMOTE_APP_URL=http://localhost:3001

# .env.staging
NODE_ENV=staging
REMOTE_APP_URL=https://staging-remote.example.com

# .env.production
NODE_ENV=production
REMOTE_APP_URL=https://remote.example.com
```

**Why this works**: Build tools (Webpack/Vite) will read these files and replace `process.env.REMOTE_APP_URL` in your code with the actual URL.

### Step 2: Configure Webpack to Use Environment Variables

```js
// webpack.config.js
require('dotenv').config({ path: `.env.${process.env.NODE_ENV}` });
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        // This gets replaced at BUILD TIME with the actual URL from .env file
        remoteApp: `remoteApp@${process.env.REMOTE_APP_URL}/remoteEntry.js`,
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

**What's happening here**:
1. `dotenv` reads the appropriate `.env` file based on `NODE_ENV`
2. Webpack replaces `${process.env.REMOTE_APP_URL}` with the actual value
3. The final built JavaScript will have the hardcoded URL (e.g., `https://remote.example.com`)

### Step 3: Build for Each Environment

```bash
# For development (uses .env.development)
NODE_ENV=development yarn build
# Result: Bundle contains "http://localhost:3001/remoteEntry.js"

# For production (uses .env.production)
NODE_ENV=production yarn build
# Result: Bundle contains "https://remote.example.com/remoteEntry.js"
```

### Step 4: Use the Remote Normally in Your Code

```tsx
// host/src/App.tsx
import { Suspense, lazy } from 'react';

// This works because Webpack already knows about "remoteApp" from the config
const RemoteApp = lazy(() => import('remoteApp/App'));

export default function App() {
  return (
    <div>
      <h1>Host Application ({process.env.NODE_ENV})</h1>
      <Suspense fallback={<div>Loading remote...</div>}>
        <RemoteApp />
      </Suspense>
    </div>
  );
}
```

✅ **Verify it works**:
```bash
# Start in dev mode
NODE_ENV=development yarn dev
# Open browser DevTools → Network tab → you should see request to localhost:3001

# Build for production
NODE_ENV=production yarn build
# Inspect dist/main.js → you should find "https://remote.example.com" in the code
```

---

## 🔧 Vite Alternative (Same Concept)

If you're using Vite instead of Webpack, the approach is nearly identical:

```ts
// vite.config.ts
import { defineConfig, loadEnv } from 'vite';
import federation from '@originjs/vite-plugin-federation';

export default defineConfig(({ mode }) => {
  // Load .env file based on mode (development/staging/production)
  const env = loadEnv(mode, process.cwd());

  return {
    plugins: [
      federation({
        name: 'host',
        remotes: {
          // Vite uses VITE_ prefix for env variables
          remoteApp: `${env.VITE_REMOTE_APP_URL}/assets/remoteEntry.js`,
        },
        shared: ['react', 'react-dom'],
      }),
    ],
  };
});
```

**Key difference**: Vite requires environment variables to be prefixed with `VITE_`:

```bash
# .env.development
VITE_REMOTE_APP_URL=http://localhost:3001

# .env.production
VITE_REMOTE_APP_URL=https://remote.example.com
```

Build commands:
```bash
vite build --mode development  # Uses .env.development
vite build --mode production   # Uses .env.production
```

---

## 🎯 Runtime Configuration: When You Need More Flexibility

Now let's explore the runtime approach, which is more complex but gives you superpowers like updating remote URLs without rebuilding.

### The Big Picture

Instead of hardcoding remote URLs at build time, your app:
1. **Loads** → Fetches a config file (e.g., `/config/production.json`)
2. **Reads** → Parses which remote URLs to use
3. **Dynamically loads** → Manually loads the remote using JavaScript

### Step 1: Create Configuration Files

Create a `public/config/` folder with JSON files:

```json
// public/config/development.json
{
  "remotes": {
    "remoteApp": {
      "url": "http://localhost:3001/remoteEntry.js",
      "scope": "remoteApp"
    },
    "dashboard": {
      "url": "http://localhost:3002/remoteEntry.js",
      "scope": "dashboardApp"
    }
  }
}
```

```json
// public/config/production.json
{
  "remotes": {
    "remoteApp": {
      "url": "https://remote.example.com/remoteEntry.js",
      "scope": "remoteApp"
    },
    "dashboard": {
      "url": "https://dashboard.example.com/remoteEntry.js",
      "scope": "dashboardApp"
    }
  }
}
```

**Why separate files?** Your server (Nginx/Apache/S3) can serve different config files based on the environment without rebuilding your app.

### Step 2: Create a Config Service

This service fetches and manages your remote configuration:

```ts
// host/src/services/configService.ts

interface RemoteConfig {
  url: string;
  scope: string;
}

class ConfigService {
  private config: Record<string, RemoteConfig> | null = null;

  // Call this BEFORE rendering your app
  async initialize(): Promise<void> {
    // Determine which config file to load
    // In production, you might detect this from window.location.hostname
    const env = process.env.NODE_ENV || 'development';

    const response = await fetch(`/config/${env}.json`);
    const data = await response.json();

    this.config = data.remotes;
    console.log(`✅ Loaded config for ${env}:`, this.config);
  }

  getRemote(remoteName: string): RemoteConfig {
    if (!this.config) {
      throw new Error('Config not initialized! Call configService.initialize() first');
    }

    const remote = this.config[remoteName];
    if (!remote) {
      throw new Error(`Remote "${remoteName}" not found in config`);
    }

    return remote;
  }
}

export const configService = new ConfigService();
```

**Key insight**: This runs at startup, before your React app renders, to fetch the configuration.

### Step 3: Create a Remote Loader Utility

This function dynamically loads a remote at runtime:

```ts
// host/src/utils/loadRemote.ts

interface LoadRemoteOptions {
  url: string;      // Where to fetch remoteEntry.js from
  scope: string;    // The remote's name (from its ModuleFederation config)
  module: string;   // Which exposed module to import (e.g., './App')
}

export async function loadRemote<T = any>({
  url,
  scope,
  module,
}: LoadRemoteOptions): Promise<T> {

  // Step 1: Inject the remote's script tag into the page
  await loadRemoteEntry(url);

  // Step 2: Initialize Module Federation's sharing mechanism
  // (This is webpack internals - it sets up shared dependencies like React)
  await __webpack_init_sharing__('default');

  // Step 3: Get the remote container from the global window object
  // When remoteEntry.js loads, it creates window[scope] (e.g., window.remoteApp)
  const container = (window as any)[scope];
  if (!container) {
    throw new Error(`Remote container "${scope}" not found. Did ${url} load correctly?`);
  }

  // Step 4: Tell the remote about our shared dependencies
  await container.init(__webpack_share_scopes__.default);

  // Step 5: Get the specific module we want (e.g., './App')
  const factory = await container.get(module);
  const Module = factory();

  return Module;
}

// Helper function to inject the <script> tag
function loadRemoteEntry(url: string): Promise<void> {
  return new Promise((resolve, reject) => {
    // Don't load the same remote twice
    const existing = document.querySelector(`script[src="${url}"]`);
    if (existing) {
      resolve();
      return;
    }

    const script = document.createElement('script');
    script.src = url;
    script.type = 'text/javascript';
    script.async = true;

    script.onload = () => {
      console.log(`✅ Loaded remote: ${url}`);
      resolve();
    };

    script.onerror = () => {
      console.error(`❌ Failed to load remote: ${url}`);
      reject(new Error(`Failed to load ${url}`));
    };

    document.head.appendChild(script);
  });
}

// These are webpack internals - they exist at runtime when using Module Federation
declare const __webpack_init_sharing__: (scope: string) => Promise<void>;
declare const __webpack_share_scopes__: { default: any };
```

**What's happening**:
- `loadRemoteEntry()`: Downloads the remote's JavaScript file
- `__webpack_init_sharing__`: Webpack-specific function that sets up shared dependencies
- `container.init()`: Tells the remote which React/libraries to use (prevents duplicates)
- `container.get()`: Retrieves the exposed module

### Step 4: Initialize Config Before Rendering

You need to fetch the config BEFORE your React app renders:

```tsx
// host/src/index.tsx
import { configService } from './services/configService';

// Step 1: Initialize config
configService.initialize()
  .then(() => {
    // Step 2: Only render app after config is ready
    import('./bootstrap');
  })
  .catch((error) => {
    console.error('Failed to initialize config:', error);
    document.body.innerHTML = '<h1>Configuration Error</h1>';
  });
```

```tsx
// host/src/bootstrap.tsx (the actual React app)
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);
```

**Why the split?** We need config loaded before any `import()` statements that depend on it.

### Step 5: Use Runtime Config in Components

```tsx
// host/src/App.tsx
import { Suspense, lazy } from 'react';
import { configService } from './services/configService';
import { loadRemote } from './utils/loadRemote';

// This lazy load happens at RUNTIME using the config
const RemoteApp = lazy(() => {
  const config = configService.getRemote('remoteApp');

  return loadRemote({
    url: config.url,
    scope: config.scope,
    module: './App',  // The exposed module from the remote
  });
});

export default function App() {
  return (
    <div>
      <h1>Host Application</h1>
      <Suspense fallback={<div>Loading remote...</div>}>
        <RemoteApp />
      </Suspense>
    </div>
  );
}
```

### Step 6: Deploy with Environment-Specific Configs

Your deployment strategy changes:

```bash
# Build ONCE (no environment-specific builds needed!)
yarn build

# Deploy to dev server
aws s3 cp dist/ s3://dev-bucket/ --recursive
aws s3 cp config/development.json s3://dev-bucket/config/production.json
# ↑ Trick: Rename development.json to production.json so the app loads dev URLs

# Deploy to prod server
aws s3 cp dist/ s3://prod-bucket/ --recursive
aws s3 cp config/production.json s3://prod-bucket/config/production.json
# ↑ Use the actual production.json
```

**The magic**: Same `dist/` folder, different config file = different remote URLs!

---

## 🎨 Advanced Pattern: Centralized Config Server

For large organizations with many micro-frontends, hardcoding URLs even in JSON files becomes a pain. Instead, use a **config server**.

### The Concept
Instead of static JSON files, your app fetches config from an API:

```
GET https://config-api.example.com/mfe/host?env=production

Response:
{
  "remotes": {
    "remoteApp": {
      "url": "https://remote-v2.example.com/remoteEntry.js",
      "scope": "remoteApp",
      "enabled": true
    },
    "dashboard": {
      "url": "https://dashboard.example.com/remoteEntry.js",
      "scope": "dashboardApp",
      "enabled": false  ← Can toggle features remotely!
    }
  }
}
```

### Updated Config Service

```ts
// host/src/services/configService.ts
class ConfigService {
  private config: any = null;

  async initialize(): Promise<void> {
    // Detect environment from hostname (or use env variable)
    const env = this.detectEnvironment();

    // Fetch from config server instead of static file
    const response = await fetch(
      `https://config-api.example.com/mfe/host?env=${env}`
    );

    this.config = await response.json();
  }

  private detectEnvironment(): string {
    const hostname = window.location.hostname;

    if (hostname.includes('localhost')) return 'development';
    if (hostname.includes('staging')) return 'staging';
    return 'production';
  }

  getRemote(remoteName: string) {
    const remote = this.config.remotes[remoteName];

    if (!remote || !remote.enabled) {
      throw new Error(`Remote "${remoteName}" is disabled or not found`);
    }

    return remote;
  }

  // Bonus: Check if a remote is available
  isRemoteEnabled(remoteName: string): boolean {
    return this.config?.remotes[remoteName]?.enabled ?? false;
  }
}
```

### Benefits
✅ Update remote URLs without redeploying ANY app
✅ Feature flags - enable/disable remotes remotely
✅ A/B testing - serve different remote URLs to different users
✅ Emergency rollback - switch to previous version instantly

---

## 🌍 Real-World Pattern: Multi-Region Deployment

If your app serves global users, you might want region-specific remote URLs for better performance:

```ts
// host/src/config/regions.ts

type Region = 'us-east' | 'us-west' | 'eu-central' | 'ap-southeast';

const REGIONAL_CONFIGS: Record<Region, Record<string, string>> = {
  'us-east': {
    remoteApp: 'https://us-east-remote.example.com/remoteEntry.js',
    dashboard: 'https://us-east-dashboard.example.com/remoteEntry.js',
  },
  'eu-central': {
    remoteApp: 'https://eu-remote.example.com/remoteEntry.js',
    dashboard: 'https://eu-dashboard.example.com/remoteEntry.js',
  },
  // ... more regions
};

function detectRegion(): Region {
  // Option 1: Use browser's geolocation API
  // Option 2: Use CloudFlare/AWS geolocation headers
  // Option 3: Let user choose and store in localStorage

  const saved = localStorage.getItem('preferred-region');
  return (saved as Region) || 'us-east';
}

export function getRegionalRemoteUrl(remoteName: string): string {
  const region = detectRegion();
  return REGIONAL_CONFIGS[region][remoteName];
}
```

**Why this helps**: Users in Europe load from EU servers, reducing latency from ~200ms to ~20ms.

---

## ⚠️ Common Pitfalls & Solutions

### Pitfall 1: "Module not found" in Production

**Symptom**: Works in dev, but production build can't find the remote.

**Cause**: Your production build has the dev URL baked in.

**Solution**:
```bash
# ❌ Wrong - builds with dev config
yarn build

# ✅ Correct - explicitly set environment
NODE_ENV=production yarn build

# Or in package.json:
{
  "scripts": {
    "build:dev": "NODE_ENV=development webpack",
    "build:prod": "NODE_ENV=production webpack"
  }
}
```

### Pitfall 2: CORS Errors When Loading Remote

**Symptom**: `Access to script at 'https://remote.example.com/remoteEntry.js' blocked by CORS`

**Cause**: The remote server doesn't allow cross-origin requests.

**Solution**: Configure your remote server (Nginx/Apache) to send CORS headers:

```nginx
# nginx.conf on remote server
location ~* \.(js|json)$ {
    add_header Access-Control-Allow-Origin "*";
    add_header Access-Control-Allow-Methods "GET, OPTIONS";
    add_header Access-Control-Allow-Headers "Content-Type";
}
```

For development, you can use a proxy:
```js
// webpack.config.js (host)
devServer: {
  proxy: {
    '/remote': {
      target: 'http://localhost:3001',
      pathRewrite: { '^/remote': '' },
    },
  },
}

// Now use: remoteApp: 'remoteApp@/remote/remoteEntry.js'
```

### Pitfall 3: Hardcoded URLs in Remote's publicPath

**Symptom**: Remote loads, but its chunks/assets fail to load (404 errors for `chunk.js`).

**Cause**: The remote's webpack config has wrong `publicPath`.

**Solution**:
```js
// remote/webpack.config.js
module.exports = {
  output: {
    publicPath: 'auto',  // ✅ Automatically detects correct path
    // OR hardcode for production:
    // publicPath: 'https://remote.example.com/',
  },
};
```

**Why it matters**: When the remote loads additional chunks (code splitting), it needs to know where to fetch them from.

### Pitfall 4: Environment Variable Not Replaced

**Symptom**: Built code contains literal `process.env.REMOTE_APP_URL` string instead of actual URL.

**Cause**: Webpack isn't configured to replace environment variables.

**Solution**: Use `webpack.DefinePlugin`:

```js
// webpack.config.js
const webpack = require('webpack');
require('dotenv').config({ path: `.env.${process.env.NODE_ENV}` });

module.exports = {
  plugins: [
    new webpack.DefinePlugin({
      'process.env.REMOTE_APP_URL': JSON.stringify(process.env.REMOTE_APP_URL),
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),
    }),
    // ... other plugins
  ],
};
```

Or install `dotenv-webpack`:
```bash
yarn add -D dotenv-webpack
```

```js
const Dotenv = require('dotenv-webpack');

module.exports = {
  plugins: [
    new Dotenv({
      path: `.env.${process.env.NODE_ENV}`,
    }),
  ],
};
```

### Pitfall 5: Cached remoteEntry.js Serving Stale URLs

**Symptom**: You deployed a new version of your remote to a different URL, but users still load the old version. Or worse, the host loads an outdated `remoteEntry.js` that points to a decommissioned server.

**Cause**: Browsers or CDNs are caching `remoteEntry.js`, preventing users from getting the latest remote configuration.

**Why it's critical**: Unlike regular JavaScript bundles (which should be cached), `remoteEntry.js` is a **manifest file** that tells the host where to find the remote's chunks. If it's cached, your host will never discover new remote URLs.

**Solution**: Configure cache headers to **never cache** `remoteEntry.js`:

**Nginx configuration:**
```nginx
# nginx.conf
location = /remoteEntry.js {
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires "0";
}

# Cache other JS files normally
location ~* \.js$ {
    add_header Cache-Control "public, max-age=31536000, immutable";
}
```

**Apache configuration:**
```apache
# .htaccess or apache.conf
<Files "remoteEntry.js">
    Header set Cache-Control "no-cache, no-store, must-revalidate"
    Header set Pragma "no-cache"
    Header set Expires "0"
</Files>

<FilesMatch "\.(js)$">
    Header set Cache-Control "public, max-age=31536000, immutable"
</FilesMatch>
```

**CloudFront/CDN configuration:**
```json
{
  "CacheBehaviors": [
    {
      "PathPattern": "*/remoteEntry.js",
      "MinTTL": 0,
      "MaxTTL": 0,
      "DefaultTTL": 0
    }
  ]
}
```

**Verification:**
```bash
# Check cache headers
curl -I https://remote.example.com/remoteEntry.js | grep -i cache

# Should show:
# Cache-Control: no-cache, no-store, must-revalidate
# NOT: Cache-Control: max-age=3600
```

**Pro tip**: Use versioned URLs for everything EXCEPT `remoteEntry.js`:
```js
// Good: Chunks are versioned and cached forever
output: {
  filename: '[name].[contenthash].js',  // e.g., main.a1b2c3.js
}

// remoteEntry.js stays unversioned and uncached
new ModuleFederationPlugin({
  filename: 'remoteEntry.js',  // Always the same name
})
```

---

## 🎓 Decision Guide: Which Approach Should I Use?

Use this flowchart to decide:

```
Do you need to change remote URLs without rebuilding?
│
├─ NO → Use Compile-Time Configuration
│        ✅ Simpler
│        ✅ Faster runtime
│        ✅ Type-safe
│
└─ YES → Do you have many micro-frontends to manage?
         │
         ├─ NO (< 5 remotes) → Use Runtime Config with JSON files
         │                      ✅ One build for all envs
         │                      ✅ Update URLs independently
         │
         └─ YES (5+ remotes) → Use Centralized Config Server
                                ✅ All benefits of runtime config
                                ✅ Feature flags
                                ✅ No file management needed
```

**Most common choice**: Start with **Compile-Time Configuration**. Migrate to runtime config later if you need it.

---

## ✅ Best Practices Summary

- [ ] **Never hardcode production URLs** in development code
- [ ] **Use `.env` files** for compile-time config (gitignore them if they have secrets)
- [ ] **Validate URLs** at build time (fail fast if REMOTE_APP_URL is undefined)
- [ ] **Test each environment** before deploying (don't assume prod config is correct)
- [ ] **Use HTTPS** in staging/production (mixed content errors are painful)
- [ ] **Set `publicPath: 'auto'`** in remotes to avoid chunk loading issues
- [ ] **Monitor remote loading failures** in production (404s should alert you)
- [ ] **Document your URLs** somewhere accessible to the team (wiki/README)

---

## 🚀 Quick Reference Card

### Compile-Time (Most Common)

```bash
# 1. Create .env files
echo "REMOTE_APP_URL=http://localhost:3001" > .env.development
echo "REMOTE_APP_URL=https://remote.example.com" > .env.production

# 2. Configure webpack
new ModuleFederationPlugin({
  remotes: {
    remoteApp: `remoteApp@${process.env.REMOTE_APP_URL}/remoteEntry.js`,
  },
})

# 3. Build for each environment
NODE_ENV=development yarn build  # Uses .env.development
NODE_ENV=production yarn build   # Uses .env.production
```

### Runtime (More Flexible)

```js
// 1. Fetch config at startup
await configService.initialize();

// 2. Load remotes dynamically
const RemoteApp = lazy(() => {
  const config = configService.getRemote('remoteApp');
  return loadRemote({
    url: config.url,
    scope: config.scope,
    module: './App',
  });
});
```

### TypeScript Types for Quick Copy-Paste

```ts
// config/types.ts
export type Environment = 'development' | 'staging' | 'production';

export interface RemoteConfig {
  url: string;
  scope: string;
  enabled?: boolean;
}

export interface RemotesConfig {
  [remoteName: string]: RemoteConfig;
}

export interface EnvironmentConfig {
  remotes: RemotesConfig;
  apiBaseUrl?: string;
  cdnUrl?: string;
}

// Usage
const config: EnvironmentConfig = {
  remotes: {
    remoteApp: {
      url: 'https://remote.example.com/remoteEntry.js',
      scope: 'remoteApp',
      enabled: true,
    },
  },
};
```

```ts
// utils/loadRemote.ts - Full TypeScript version
interface LoadRemoteOptions {
  url: string;
  scope: string;
  module: string;
}

declare global {
  interface Window {
    [key: string]: any;
  }
}

declare const __webpack_init_sharing__: (scope: string) => Promise<void>;
declare const __webpack_share_scopes__: { default: any };

export async function loadRemote<T = any>({
  url,
  scope,
  module,
}: LoadRemoteOptions): Promise<{ default: T }> {
  await loadRemoteEntry(url);
  await __webpack_init_sharing__('default');

  const container = window[scope];
  if (!container) {
    throw new Error(`Remote container "${scope}" not found at ${url}`);
  }

  await container.init(__webpack_share_scopes__.default);
  const factory = await container.get(module);
  return factory();
}

function loadRemoteEntry(url: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const existing = document.querySelector(`script[src="${url}"]`);
    if (existing) {
      resolve();
      return;
    }

    const script = document.createElement('script');
    script.src = url;
    script.async = true;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Failed to load ${url}`));
    document.head.appendChild(script);
  });
}
```

---

## 📖 Next Steps

Now that you can load remotes from different environments, the next challenge is **hosting those remotes**.

### 🔜 **Next Topic**: [5.20 Hosting Builds on Apache/Nginx/S3/CDN](./5.20-hosting-builds.md)

**What you'll learn**:
- Serving micro-frontends from various platforms (Nginx, Apache, S3, CloudFront)
- Cache strategies for `remoteEntry.js` (hint: don't cache it!)
- CORS configuration
- HTTPS setup

### Your Learning Path:
```
✅ Expose & Consume Components
✅ React.lazy + Suspense
✅ Environment-based Loading (You are here!)
→  Hosting & Deployment
→  RemoteEntry URLs & PublicPath
→  CI/CD for MFEs
```

---

## 📚 References & Further Reading

- [Webpack Environment Variables](https://webpack.js.org/guides/environment-variables/) - Official guide to using env vars in webpack
- [Module Federation Dynamic Remotes](https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers) - Official docs on runtime remote loading
- [Vite Environment Variables](https://vitejs.dev/guide/env-and-mode.html) - Vite's approach to env vars
- [Module Federation Examples - Dynamic Remotes](https://github.com/module-federation/module-federation-examples/tree/master/dynamic-remotes) - Working code examples
