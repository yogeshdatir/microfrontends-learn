# 5.19 Environment-based Remote Loading (dev, staging, prod)

> **What you'll learn**: How to load remote micro-frontends from different URLs based on your deployment environment, without hardcoding production URLs into your development code

---

## ü§î Why This Matters

### The Problem
Imagine you're developing a micro-frontend host app on your laptop. You configure it to load a remote app:

```js
remotes: {
  remoteApp: 'remoteApp@http://localhost:3001/remoteEntry.js'  // ‚ùå This breaks in production!
}
```

This works locally, but when you deploy to production, your app is still trying to reach `localhost:3001` - which doesn't exist on your user's browser! You need the production build to point to `https://remote.example.com` instead.

### The Challenge
You have **one codebase** but need **different remote URLs** depending on where it's running:

| Environment | Remote URL | When Used |
|-------------|-----------|-----------|
| **Development** | `http://localhost:3001` | Your laptop while coding |
| **Staging** | `https://staging-remote.example.com` | QA testing environment |
| **Production** | `https://remote.example.com` | Live site for real users |

**The goal**: Write your code once, but have it automatically use the right URL for each environment.

---

## üí° The Two Main Approaches

Before diving into code, understand there are **two fundamentally different strategies** for solving this problem. Choosing the right one depends on your deployment workflow.

### Approach 1: Compile-Time Configuration (Most Common)
**How it works**: The remote URL is "baked into" your JavaScript bundle when you build it.

**When you'd use it**:
- You build separate bundles for dev/staging/prod (e.g., `yarn build:dev`, `yarn build:prod`)
- Your CI/CD pipeline creates environment-specific builds
- You're okay rebuilding to change which remote URL is used

**Pros**:
‚úÖ Simpler code - just use normal `import()` statements
‚úÖ Type-safe - TypeScript knows about your remotes at compile time
‚úÖ Faster runtime - no extra network requests for configuration

**Cons**:
‚ùå Need to rebuild to switch environments
‚ùå Can't change remote URLs after deployment (without rebuilding)

---

### Approach 2: Runtime Configuration (More Flexible)
**How it works**: Your app fetches a configuration file or API when it first loads, then uses that to determine remote URLs.

**When you'd use it**:
- You want one build that works in all environments
- You need to change remote URLs without redeploying (e.g., for A/B testing)
- You have a centralized config server
- You want feature flags to enable/disable remotes

**Pros**:
‚úÖ One build for all environments
‚úÖ Can update remote URLs without rebuilding
‚úÖ Enables advanced scenarios (feature flags, A/B testing)

**Cons**:
‚ùå More complex code - manual remote loading
‚ùå Slower startup - must fetch config first
‚ùå Requires runtime infrastructure (config server or static config files)

### Visual Comparison

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    COMPILE-TIME CONFIGURATION                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                      ‚îÇ
‚îÇ  Development Build          Staging Build          Production Build ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ webpack.config‚îÇ          ‚îÇ webpack.config‚îÇ       ‚îÇ webpack.config‚îÇ ‚îÇ
‚îÇ  ‚îÇ + .env.dev    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  ‚îÇ + .env.staging‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ + .env.prod   ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îÇ         ‚îÇ                          ‚îÇ                      ‚îÇ         ‚îÇ
‚îÇ         ‚ñº                          ‚ñº                      ‚ñº         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ main.js      ‚îÇ          ‚îÇ main.js      ‚îÇ       ‚îÇ main.js      ‚îÇ ‚îÇ
‚îÇ  ‚îÇ localhost:   ‚îÇ          ‚îÇ staging.com  ‚îÇ       ‚îÇ example.com  ‚îÇ ‚îÇ
‚îÇ  ‚îÇ 3001 ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  Hardcoded URLs different in each build         ‚îÇ
‚îÇ                                                                      ‚îÇ
‚îÇ  ‚úÖ Simple  ‚úÖ Fast  ‚ùå Must rebuild to change URLs                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     RUNTIME CONFIGURATION                            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                      ‚îÇ
‚îÇ              ONE Build for ALL Environments                          ‚îÇ
‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                        ‚îÇ
‚îÇ              ‚îÇ webpack.config‚îÇ                                       ‚îÇ
‚îÇ              ‚îÇ (no env vars) ‚îÇ                                       ‚îÇ
‚îÇ              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                        ‚îÇ
‚îÇ                      ‚îÇ                                               ‚îÇ
‚îÇ                      ‚ñº                                               ‚îÇ
‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                        ‚îÇ
‚îÇ              ‚îÇ main.js      ‚îÇ ‚Üê‚îÄ‚îÄ‚îÄ Same bundle deployed everywhere  ‚îÇ
‚îÇ              ‚îÇ (generic)    ‚îÇ                                        ‚îÇ
‚îÇ              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                        ‚îÇ
‚îÇ                     ‚îÇ                                                ‚îÇ
‚îÇ         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                   ‚îÇ
‚îÇ         ‚ñº           ‚ñº           ‚ñº                                    ‚îÇ
‚îÇ  Dev Server   Staging Server   Prod Server                          ‚îÇ
‚îÇ  Serves:      Serves:          Serves:                              ‚îÇ
‚îÇ  dev.json     staging.json     prod.json                            ‚îÇ
‚îÇ  localhost    staging.com      example.com                          ‚îÇ
‚îÇ                                                                      ‚îÇ
‚îÇ  ‚úÖ Flexible  ‚úÖ One build  ‚ùå Complex  ‚ùå Slower startup             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üöÄ Quick Start: Compile-Time Configuration

This is the approach **most teams start with** because it's simpler. We'll use environment variables that get replaced during the build.

### Step 1: Create Environment Variable Files

Create three files in your host app's root directory:

```bash
# .env.development
NODE_ENV=development
REMOTE_APP_URL=http://localhost:3001

# .env.staging
NODE_ENV=staging
REMOTE_APP_URL=https://staging-remote.example.com

# .env.production
NODE_ENV=production
REMOTE_APP_URL=https://remote.example.com
```

**Why this works**: Build tools (Webpack/Vite) will read these files and replace `process.env.REMOTE_APP_URL` in your code with the actual URL.

### Step 2: Configure Webpack to Use Environment Variables

```js
// webpack.config.js
require('dotenv').config({ path: `.env.${process.env.NODE_ENV}` });
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      remotes: {
        // This gets replaced at BUILD TIME with the actual URL from .env file
        remoteApp: `remoteApp@${process.env.REMOTE_APP_URL}/remoteEntry.js`,
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true },
      },
    }),
  ],
};
```

**What's happening here**:
1. `dotenv` reads the appropriate `.env` file based on `NODE_ENV`
2. Webpack replaces `${process.env.REMOTE_APP_URL}` with the actual value
3. The final built JavaScript will have the hardcoded URL (e.g., `https://remote.example.com`)

### Step 3: Build for Each Environment

```bash
# For development (uses .env.development)
NODE_ENV=development yarn build
# Result: Bundle contains "http://localhost:3001/remoteEntry.js"

# For production (uses .env.production)
NODE_ENV=production yarn build
# Result: Bundle contains "https://remote.example.com/remoteEntry.js"
```

### Step 4: Use the Remote Normally in Your Code

```tsx
// host/src/App.tsx
import { Suspense, lazy } from 'react';

// This works because Webpack already knows about "remoteApp" from the config
const RemoteApp = lazy(() => import('remoteApp/App'));

export default function App() {
  return (
    <div>
      <h1>Host Application ({process.env.NODE_ENV})</h1>
      <Suspense fallback={<div>Loading remote...</div>}>
        <RemoteApp />
      </Suspense>
    </div>
  );
}
```

‚úÖ **Verify it works**:
```bash
# Start in dev mode
NODE_ENV=development yarn dev
# Open browser DevTools ‚Üí Network tab ‚Üí you should see request to localhost:3001

# Build for production
NODE_ENV=production yarn build
# Inspect dist/main.js ‚Üí you should find "https://remote.example.com" in the code
```

---

## üîß Vite Alternative (Same Concept)

If you're using Vite instead of Webpack, the approach is nearly identical:

```ts
// vite.config.ts
import { defineConfig, loadEnv } from 'vite';
import federation from '@originjs/vite-plugin-federation';

export default defineConfig(({ mode }) => {
  // Load .env file based on mode (development/staging/production)
  const env = loadEnv(mode, process.cwd());

  return {
    plugins: [
      federation({
        name: 'host',
        remotes: {
          // Vite uses VITE_ prefix for env variables
          remoteApp: `${env.VITE_REMOTE_APP_URL}/assets/remoteEntry.js`,
        },
        shared: ['react', 'react-dom'],
      }),
    ],
  };
});
```

**Key difference**: Vite requires environment variables to be prefixed with `VITE_`:

```bash
# .env.development
VITE_REMOTE_APP_URL=http://localhost:3001

# .env.production
VITE_REMOTE_APP_URL=https://remote.example.com
```

Build commands:
```bash
vite build --mode development  # Uses .env.development
vite build --mode production   # Uses .env.production
```

---

## üéØ Runtime Configuration: When You Need More Flexibility

Now let's explore the runtime approach, which is more complex but gives you superpowers like updating remote URLs without rebuilding.

### The Big Picture

Instead of hardcoding remote URLs at build time, your app:
1. **Loads** ‚Üí Fetches a config file (e.g., `/config/production.json`)
2. **Reads** ‚Üí Parses which remote URLs to use
3. **Dynamically loads** ‚Üí Manually loads the remote using JavaScript

### Step 1: Create Configuration Files

Create a `public/config/` folder with JSON files:

```json
// public/config/development.json
{
  "remotes": {
    "remoteApp": {
      "url": "http://localhost:3001/remoteEntry.js",
      "scope": "remoteApp"
    },
    "dashboard": {
      "url": "http://localhost:3002/remoteEntry.js",
      "scope": "dashboardApp"
    }
  }
}
```

```json
// public/config/production.json
{
  "remotes": {
    "remoteApp": {
      "url": "https://remote.example.com/remoteEntry.js",
      "scope": "remoteApp"
    },
    "dashboard": {
      "url": "https://dashboard.example.com/remoteEntry.js",
      "scope": "dashboardApp"
    }
  }
}
```

**Why separate files?** Your server (Nginx/Apache/S3) can serve different config files based on the environment without rebuilding your app.

### Step 2: Create a Config Service

This service fetches and manages your remote configuration:

```ts
// host/src/services/configService.ts

interface RemoteConfig {
  url: string;
  scope: string;
}

class ConfigService {
  private config: Record<string, RemoteConfig> | null = null;

  // Call this BEFORE rendering your app
  async initialize(): Promise<void> {
    // Determine which config file to load
    // In production, you might detect this from window.location.hostname
    const env = process.env.NODE_ENV || 'development';

    const response = await fetch(`/config/${env}.json`);
    const data = await response.json();

    this.config = data.remotes;
    console.log(`‚úÖ Loaded config for ${env}:`, this.config);
  }

  getRemote(remoteName: string): RemoteConfig {
    if (!this.config) {
      throw new Error('Config not initialized! Call configService.initialize() first');
    }

    const remote = this.config[remoteName];
    if (!remote) {
      throw new Error(`Remote "${remoteName}" not found in config`);
    }

    return remote;
  }
}

export const configService = new ConfigService();
```

**Key insight**: This runs at startup, before your React app renders, to fetch the configuration.

### Step 3: Create a Remote Loader Utility

This function dynamically loads a remote at runtime:

```ts
// host/src/utils/loadRemote.ts

interface LoadRemoteOptions {
  url: string;      // Where to fetch remoteEntry.js from
  scope: string;    // The remote's name (from its ModuleFederation config)
  module: string;   // Which exposed module to import (e.g., './App')
}

export async function loadRemote<T = any>({
  url,
  scope,
  module,
}: LoadRemoteOptions): Promise<T> {

  // Step 1: Inject the remote's script tag into the page
  await loadRemoteEntry(url);

  // Step 2: Initialize Module Federation's sharing mechanism
  // (This is webpack internals - it sets up shared dependencies like React)
  await __webpack_init_sharing__('default');

  // Step 3: Get the remote container from the global window object
  // When remoteEntry.js loads, it creates window[scope] (e.g., window.remoteApp)
  const container = (window as any)[scope];
  if (!container) {
    throw new Error(`Remote container "${scope}" not found. Did ${url} load correctly?`);
  }

  // Step 4: Tell the remote about our shared dependencies
  await container.init(__webpack_share_scopes__.default);

  // Step 5: Get the specific module we want (e.g., './App')
  const factory = await container.get(module);
  const Module = factory();

  return Module;
}

// Helper function to inject the <script> tag
function loadRemoteEntry(url: string): Promise<void> {
  return new Promise((resolve, reject) => {
    // Don't load the same remote twice
    const existing = document.querySelector(`script[src="${url}"]`);
    if (existing) {
      resolve();
      return;
    }

    const script = document.createElement('script');
    script.src = url;
    script.type = 'text/javascript';
    script.async = true;

    script.onload = () => {
      console.log(`‚úÖ Loaded remote: ${url}`);
      resolve();
    };

    script.onerror = () => {
      console.error(`‚ùå Failed to load remote: ${url}`);
      reject(new Error(`Failed to load ${url}`));
    };

    document.head.appendChild(script);
  });
}

// These are webpack internals - they exist at runtime when using Module Federation
declare const __webpack_init_sharing__: (scope: string) => Promise<void>;
declare const __webpack_share_scopes__: { default: any };
```

**What's happening**:
- `loadRemoteEntry()`: Downloads the remote's JavaScript file
- `__webpack_init_sharing__`: Webpack-specific function that sets up shared dependencies
- `container.init()`: Tells the remote which React/libraries to use (prevents duplicates)
- `container.get()`: Retrieves the exposed module

### Step 4: Initialize Config Before Rendering

You need to fetch the config BEFORE your React app renders:

```tsx
// host/src/index.tsx
import { configService } from './services/configService';

// Step 1: Initialize config
configService.initialize()
  .then(() => {
    // Step 2: Only render app after config is ready
    import('./bootstrap');
  })
  .catch((error) => {
    console.error('Failed to initialize config:', error);
    document.body.innerHTML = '<h1>Configuration Error</h1>';
  });
```

```tsx
// host/src/bootstrap.tsx (the actual React app)
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<App />);
```

**Why the split?** We need config loaded before any `import()` statements that depend on it.

### Step 5: Use Runtime Config in Components

```tsx
// host/src/App.tsx
import { Suspense, lazy } from 'react';
import { configService } from './services/configService';
import { loadRemote } from './utils/loadRemote';

// This lazy load happens at RUNTIME using the config
const RemoteApp = lazy(() => {
  const config = configService.getRemote('remoteApp');

  return loadRemote({
    url: config.url,
    scope: config.scope,
    module: './App',  // The exposed module from the remote
  });
});

export default function App() {
  return (
    <div>
      <h1>Host Application</h1>
      <Suspense fallback={<div>Loading remote...</div>}>
        <RemoteApp />
      </Suspense>
    </div>
  );
}
```

### Step 6: Deploy with Environment-Specific Configs

Your deployment strategy changes:

```bash
# Build ONCE (no environment-specific builds needed!)
yarn build

# Deploy to dev server
aws s3 cp dist/ s3://dev-bucket/ --recursive
aws s3 cp config/development.json s3://dev-bucket/config/production.json
# ‚Üë Trick: Rename development.json to production.json so the app loads dev URLs

# Deploy to prod server
aws s3 cp dist/ s3://prod-bucket/ --recursive
aws s3 cp config/production.json s3://prod-bucket/config/production.json
# ‚Üë Use the actual production.json
```

**The magic**: Same `dist/` folder, different config file = different remote URLs!

---

## üé® Advanced Pattern: Centralized Config Server

For large organizations with many micro-frontends, hardcoding URLs even in JSON files becomes a pain. Instead, use a **config server**.

### The Concept
Instead of static JSON files, your app fetches config from an API:

```
GET https://config-api.example.com/mfe/host?env=production

Response:
{
  "remotes": {
    "remoteApp": {
      "url": "https://remote-v2.example.com/remoteEntry.js",
      "scope": "remoteApp",
      "enabled": true
    },
    "dashboard": {
      "url": "https://dashboard.example.com/remoteEntry.js",
      "scope": "dashboardApp",
      "enabled": false  ‚Üê Can toggle features remotely!
    }
  }
}
```

### Updated Config Service

```ts
// host/src/services/configService.ts
class ConfigService {
  private config: any = null;

  async initialize(): Promise<void> {
    // Detect environment from hostname (or use env variable)
    const env = this.detectEnvironment();

    // Fetch from config server instead of static file
    const response = await fetch(
      `https://config-api.example.com/mfe/host?env=${env}`
    );

    this.config = await response.json();
  }

  private detectEnvironment(): string {
    const hostname = window.location.hostname;

    if (hostname.includes('localhost')) return 'development';
    if (hostname.includes('staging')) return 'staging';
    return 'production';
  }

  getRemote(remoteName: string) {
    const remote = this.config.remotes[remoteName];

    if (!remote || !remote.enabled) {
      throw new Error(`Remote "${remoteName}" is disabled or not found`);
    }

    return remote;
  }

  // Bonus: Check if a remote is available
  isRemoteEnabled(remoteName: string): boolean {
    return this.config?.remotes[remoteName]?.enabled ?? false;
  }
}
```

### Benefits
‚úÖ Update remote URLs without redeploying ANY app
‚úÖ Feature flags - enable/disable remotes remotely
‚úÖ A/B testing - serve different remote URLs to different users
‚úÖ Emergency rollback - switch to previous version instantly

---

## üåç Real-World Pattern: Multi-Region Deployment

If your app serves global users, you might want region-specific remote URLs for better performance:

```ts
// host/src/config/regions.ts

type Region = 'us-east' | 'us-west' | 'eu-central' | 'ap-southeast';

const REGIONAL_CONFIGS: Record<Region, Record<string, string>> = {
  'us-east': {
    remoteApp: 'https://us-east-remote.example.com/remoteEntry.js',
    dashboard: 'https://us-east-dashboard.example.com/remoteEntry.js',
  },
  'eu-central': {
    remoteApp: 'https://eu-remote.example.com/remoteEntry.js',
    dashboard: 'https://eu-dashboard.example.com/remoteEntry.js',
  },
  // ... more regions
};

function detectRegion(): Region {
  // Option 1: Use browser's geolocation API
  // Option 2: Use CloudFlare/AWS geolocation headers
  // Option 3: Let user choose and store in localStorage

  const saved = localStorage.getItem('preferred-region');
  return (saved as Region) || 'us-east';
}

export function getRegionalRemoteUrl(remoteName: string): string {
  const region = detectRegion();
  return REGIONAL_CONFIGS[region][remoteName];
}
```

**Why this helps**: Users in Europe load from EU servers, reducing latency from ~200ms to ~20ms.

---

## ‚ö†Ô∏è Common Pitfalls & Solutions

### Pitfall 1: "Module not found" in Production

**Symptom**: Works in dev, but production build can't find the remote.

**Cause**: Your production build has the dev URL baked in.

**Solution**:
```bash
# ‚ùå Wrong - builds with dev config
yarn build

# ‚úÖ Correct - explicitly set environment
NODE_ENV=production yarn build

# Or in package.json:
{
  "scripts": {
    "build:dev": "NODE_ENV=development webpack",
    "build:prod": "NODE_ENV=production webpack"
  }
}
```

### Pitfall 2: CORS Errors When Loading Remote

**Symptom**: `Access to script at 'https://remote.example.com/remoteEntry.js' blocked by CORS`

**Cause**: The remote server doesn't allow cross-origin requests.

**Solution**: Configure your remote server (Nginx/Apache) to send CORS headers:

```nginx
# nginx.conf on remote server
location ~* \.(js|json)$ {
    add_header Access-Control-Allow-Origin "*";
    add_header Access-Control-Allow-Methods "GET, OPTIONS";
    add_header Access-Control-Allow-Headers "Content-Type";
}
```

For development, you can use a proxy:
```js
// webpack.config.js (host)
devServer: {
  proxy: {
    '/remote': {
      target: 'http://localhost:3001',
      pathRewrite: { '^/remote': '' },
    },
  },
}

// Now use: remoteApp: 'remoteApp@/remote/remoteEntry.js'
```

### Pitfall 3: Hardcoded URLs in Remote's publicPath

**Symptom**: Remote loads, but its chunks/assets fail to load (404 errors for `chunk.js`).

**Cause**: The remote's webpack config has wrong `publicPath`.

**Solution**:
```js
// remote/webpack.config.js
module.exports = {
  output: {
    publicPath: 'auto',  // ‚úÖ Automatically detects correct path
    // OR hardcode for production:
    // publicPath: 'https://remote.example.com/',
  },
};
```

**Why it matters**: When the remote loads additional chunks (code splitting), it needs to know where to fetch them from.

### Pitfall 4: Environment Variable Not Replaced

**Symptom**: Built code contains literal `process.env.REMOTE_APP_URL` string instead of actual URL.

**Cause**: Webpack isn't configured to replace environment variables.

**Solution**: Use `webpack.DefinePlugin`:

```js
// webpack.config.js
const webpack = require('webpack');
require('dotenv').config({ path: `.env.${process.env.NODE_ENV}` });

module.exports = {
  plugins: [
    new webpack.DefinePlugin({
      'process.env.REMOTE_APP_URL': JSON.stringify(process.env.REMOTE_APP_URL),
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),
    }),
    // ... other plugins
  ],
};
```

Or install `dotenv-webpack`:
```bash
yarn add -D dotenv-webpack
```

```js
const Dotenv = require('dotenv-webpack');

module.exports = {
  plugins: [
    new Dotenv({
      path: `.env.${process.env.NODE_ENV}`,
    }),
  ],
};
```

### Pitfall 5: Cached remoteEntry.js Serving Stale URLs

**Symptom**: You deployed a new version of your remote to a different URL, but users still load the old version. Or worse, the host loads an outdated `remoteEntry.js` that points to a decommissioned server.

**Cause**: Browsers or CDNs are caching `remoteEntry.js`, preventing users from getting the latest remote configuration.

**Why it's critical**: Unlike regular JavaScript bundles (which should be cached), `remoteEntry.js` is a **manifest file** that tells the host where to find the remote's chunks. If it's cached, your host will never discover new remote URLs.

**Solution**: Configure cache headers to **never cache** `remoteEntry.js`:

**Nginx configuration:**
```nginx
# nginx.conf
location = /remoteEntry.js {
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires "0";
}

# Cache other JS files normally
location ~* \.js$ {
    add_header Cache-Control "public, max-age=31536000, immutable";
}
```

**Apache configuration:**
```apache
# .htaccess or apache.conf
<Files "remoteEntry.js">
    Header set Cache-Control "no-cache, no-store, must-revalidate"
    Header set Pragma "no-cache"
    Header set Expires "0"
</Files>

<FilesMatch "\.(js)$">
    Header set Cache-Control "public, max-age=31536000, immutable"
</FilesMatch>
```

**CloudFront/CDN configuration:**
```json
{
  "CacheBehaviors": [
    {
      "PathPattern": "*/remoteEntry.js",
      "MinTTL": 0,
      "MaxTTL": 0,
      "DefaultTTL": 0
    }
  ]
}
```

**Verification:**
```bash
# Check cache headers
curl -I https://remote.example.com/remoteEntry.js | grep -i cache

# Should show:
# Cache-Control: no-cache, no-store, must-revalidate
# NOT: Cache-Control: max-age=3600
```

**Pro tip**: Use versioned URLs for everything EXCEPT `remoteEntry.js`:
```js
// Good: Chunks are versioned and cached forever
output: {
  filename: '[name].[contenthash].js',  // e.g., main.a1b2c3.js
}

// remoteEntry.js stays unversioned and uncached
new ModuleFederationPlugin({
  filename: 'remoteEntry.js',  // Always the same name
})
```

---

## üéì Decision Guide: Which Approach Should I Use?

Use this flowchart to decide:

```
Do you need to change remote URLs without rebuilding?
‚îÇ
‚îú‚îÄ NO ‚Üí Use Compile-Time Configuration
‚îÇ        ‚úÖ Simpler
‚îÇ        ‚úÖ Faster runtime
‚îÇ        ‚úÖ Type-safe
‚îÇ
‚îî‚îÄ YES ‚Üí Do you have many micro-frontends to manage?
         ‚îÇ
         ‚îú‚îÄ NO (< 5 remotes) ‚Üí Use Runtime Config with JSON files
         ‚îÇ                      ‚úÖ One build for all envs
         ‚îÇ                      ‚úÖ Update URLs independently
         ‚îÇ
         ‚îî‚îÄ YES (5+ remotes) ‚Üí Use Centralized Config Server
                                ‚úÖ All benefits of runtime config
                                ‚úÖ Feature flags
                                ‚úÖ No file management needed
```

**Most common choice**: Start with **Compile-Time Configuration**. Migrate to runtime config later if you need it.

---

## ‚úÖ Best Practices Summary

- [ ] **Never hardcode production URLs** in development code
- [ ] **Use `.env` files** for compile-time config (gitignore them if they have secrets)
- [ ] **Validate URLs** at build time (fail fast if REMOTE_APP_URL is undefined)
- [ ] **Test each environment** before deploying (don't assume prod config is correct)
- [ ] **Use HTTPS** in staging/production (mixed content errors are painful)
- [ ] **Set `publicPath: 'auto'`** in remotes to avoid chunk loading issues
- [ ] **Monitor remote loading failures** in production (404s should alert you)
- [ ] **Document your URLs** somewhere accessible to the team (wiki/README)

---

## üöÄ Quick Reference Card

### Compile-Time (Most Common)

```bash
# 1. Create .env files
echo "REMOTE_APP_URL=http://localhost:3001" > .env.development
echo "REMOTE_APP_URL=https://remote.example.com" > .env.production

# 2. Configure webpack
new ModuleFederationPlugin({
  remotes: {
    remoteApp: `remoteApp@${process.env.REMOTE_APP_URL}/remoteEntry.js`,
  },
})

# 3. Build for each environment
NODE_ENV=development yarn build  # Uses .env.development
NODE_ENV=production yarn build   # Uses .env.production
```

### Runtime (More Flexible)

```js
// 1. Fetch config at startup
await configService.initialize();

// 2. Load remotes dynamically
const RemoteApp = lazy(() => {
  const config = configService.getRemote('remoteApp');
  return loadRemote({
    url: config.url,
    scope: config.scope,
    module: './App',
  });
});
```

### TypeScript Types for Quick Copy-Paste

```ts
// config/types.ts
export type Environment = 'development' | 'staging' | 'production';

export interface RemoteConfig {
  url: string;
  scope: string;
  enabled?: boolean;
}

export interface RemotesConfig {
  [remoteName: string]: RemoteConfig;
}

export interface EnvironmentConfig {
  remotes: RemotesConfig;
  apiBaseUrl?: string;
  cdnUrl?: string;
}

// Usage
const config: EnvironmentConfig = {
  remotes: {
    remoteApp: {
      url: 'https://remote.example.com/remoteEntry.js',
      scope: 'remoteApp',
      enabled: true,
    },
  },
};
```

```ts
// utils/loadRemote.ts - Full TypeScript version
interface LoadRemoteOptions {
  url: string;
  scope: string;
  module: string;
}

declare global {
  interface Window {
    [key: string]: any;
  }
}

declare const __webpack_init_sharing__: (scope: string) => Promise<void>;
declare const __webpack_share_scopes__: { default: any };

export async function loadRemote<T = any>({
  url,
  scope,
  module,
}: LoadRemoteOptions): Promise<{ default: T }> {
  await loadRemoteEntry(url);
  await __webpack_init_sharing__('default');

  const container = window[scope];
  if (!container) {
    throw new Error(`Remote container "${scope}" not found at ${url}`);
  }

  await container.init(__webpack_share_scopes__.default);
  const factory = await container.get(module);
  return factory();
}

function loadRemoteEntry(url: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const existing = document.querySelector(`script[src="${url}"]`);
    if (existing) {
      resolve();
      return;
    }

    const script = document.createElement('script');
    script.src = url;
    script.async = true;
    script.onload = () => resolve();
    script.onerror = () => reject(new Error(`Failed to load ${url}`));
    document.head.appendChild(script);
  });
}
```

---

## üìñ Next Steps

Now that you can load remotes from different environments, the next challenge is **hosting those remotes**.

### üîú **Next Topic**: [5.20 Hosting Builds on Apache/Nginx/S3/CDN](./5.20-hosting-builds.md)

**What you'll learn**:
- Serving micro-frontends from various platforms (Nginx, Apache, S3, CloudFront)
- Cache strategies for `remoteEntry.js` (hint: don't cache it!)
- CORS configuration
- HTTPS setup

### Your Learning Path:
```
‚úÖ Expose & Consume Components
‚úÖ React.lazy + Suspense
‚úÖ Environment-based Loading (You are here!)
‚Üí  Hosting & Deployment
‚Üí  RemoteEntry URLs & PublicPath
‚Üí  CI/CD for MFEs
```

---

## üìö References & Further Reading

- [Webpack Environment Variables](https://webpack.js.org/guides/environment-variables/) - Official guide to using env vars in webpack
- [Module Federation Dynamic Remotes](https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers) - Official docs on runtime remote loading
- [Vite Environment Variables](https://vitejs.dev/guide/env-and-mode.html) - Vite's approach to env vars
- [Module Federation Examples - Dynamic Remotes](https://github.com/module-federation/module-federation-examples/tree/master/dynamic-remotes) - Working code examples
